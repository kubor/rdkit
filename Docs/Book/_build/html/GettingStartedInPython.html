
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Getting Started with the RDKit in Python &#8212; The RDKit 2017.09.2 ドキュメント</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2017.09.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="The RDKit Book" href="RDKit_Book.html" />
    <link rel="prev" title="Installation" href="Install.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="RDKit_Book.html" title="The RDKit Book"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="Install.html" title="Installation"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">The RDKit 2017.09.2 ドキュメント</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
<h3><a href="index.html">目次</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Overview.html">An overview of the RDKit</a></li>
<li class="toctree-l1"><a class="reference internal" href="Install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Getting Started with the RDKit in Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-this">What is this?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reading-and-writing-molecules">Reading and Writing Molecules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reading-single-molecules">Reading single molecules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-sets-of-molecules">Reading sets of molecules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-molecules">Writing molecules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-sets-of-molecules">Writing sets of molecules</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-molecules">Working with Molecules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#looping-over-atoms-and-bonds">Looping over Atoms and Bonds</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ring-information">Ring Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modifying-molecules">Modifying molecules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#working-with-2d-molecules-generating-depictions">Working with 2D molecules: Generating Depictions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#working-with-3d-molecules">Working with 3D Molecules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preserving-molecules">Preserving Molecules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#drawing-molecules">Drawing Molecules</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#substructure-searching">Substructure Searching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#stereochemistry-in-substructure-matches">Stereochemistry in substructure matches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atom-map-indices-in-smarts">Atom Map Indices in SMARTS</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#chemical-transformations">Chemical Transformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#substructure-based-transformations">Substructure-based transformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#murcko-decomposition">Murcko Decomposition</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#maximum-common-substructure">Maximum Common Substructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fingerprinting-and-molecular-similarity">Fingerprinting and Molecular Similarity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#topological-fingerprints">Topological Fingerprints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maccs-keys">MACCS Keys</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atom-pairs-and-topological-torsions">Atom Pairs and Topological Torsions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#morgan-fingerprints-circular-fingerprints">Morgan Fingerprints (Circular Fingerprints)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#explaining-bits-from-morgan-fingerprints">Explaining bits from Morgan Fingerprints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#picking-diverse-molecules-using-fingerprints">Picking Diverse Molecules Using Fingerprints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generating-similarity-maps-using-fingerprints">Generating Similarity Maps Using Fingerprints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#descriptor-calculation">Descriptor Calculation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#visualization-of-descriptors">Visualization of Descriptors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#chemical-reactions">Chemical Reactions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#advanced-reaction-functionality">Advanced Reaction Functionality</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#protecting-atoms">Protecting Atoms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#recap-implementation">Recap Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#brics-implementation">BRICS Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-fragmentation-approaches">Other fragmentation approaches</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#chemical-features-and-pharmacophores">Chemical Features and Pharmacophores</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chemical-features">Chemical Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-pharmacophore-fingerprints">2D Pharmacophore Fingerprints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#molecular-fragments">Molecular Fragments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#non-chemical-functionality">Non-Chemical Functionality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bit-vectors">Bit vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#discrete-value-vectors">Discrete value vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-grids">3D grids</a></li>
<li class="toctree-l3"><a class="reference internal" href="#points">Points</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#getting-help">Getting Help</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-topics-warnings">Advanced Topics/Warnings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#editing-molecules">Editing Molecules</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#miscellaneous-tips-and-hints">Miscellaneous Tips and Hints</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chem-vs-allchem">Chem vs AllChem</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-sssr-problem">The SSSR Problem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#list-of-available-descriptors">List of Available Descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#list-of-available-3d-descriptors">List of Available 3D Descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#list-of-available-fingerprints">List of Available Fingerprints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#feature-definitions-used-in-the-morgan-fingerprints">Feature Definitions Used in the Morgan Fingerprints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#license">License</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="RDKit_Book.html">The RDKit Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="Cookbook.html">RDKit Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="Cartridge.html">The RDKit database cartridge</a></li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="Install.html"
                        title="前の章へ">Installation</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="RDKit_Book.html"
                        title="次の章へ">The RDKit Book</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/GettingStartedInPython.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="getting-started-with-the-rdkit-in-python">
<h1>Getting Started with the RDKit in Python<a class="headerlink" href="#getting-started-with-the-rdkit-in-python" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="what-is-this">
<h2>What is this?<a class="headerlink" href="#what-is-this" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>This document is intended to provide an overview of how one can use
the RDKit functionality from Python.  It’s not comprehensive and it’s
not a manual.</p>
<p>If you find mistakes, or have suggestions for improvements, please
either fix them yourselves in the source document (the .rst file) or
send them to the mailing list: <a class="reference external" href="mailto:rdkit-devel&#37;&#52;&#48;lists&#46;sourceforge&#46;net">rdkit-devel<span>&#64;</span>lists<span>&#46;</span>sourceforge<span>&#46;</span>net</a>
In particular, if you find yourself spending time working out how to
do something that doesn’t appear to be documented please contribute by writing
it up for this document. Contributing to the documentation is a great service
both to the RDKit community and to your future self.</p>
</div>
<div class="section" id="reading-and-writing-molecules">
<h2>Reading and Writing Molecules<a class="headerlink" href="#reading-and-writing-molecules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="reading-single-molecules">
<h3>Reading single molecules<a class="headerlink" href="#reading-single-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The majority of the basic molecular functionality is found in module <a class="reference external" href="api/rdkit.Chem-module.html">rdkit.Chem</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
</pre></div>
</div>
<p>Individual molecules can be constructed using a variety of approaches:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;Cc1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromMolFile</span><span class="p">(</span><span class="s1">&#39;data/input.mol&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stringWithMolData</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data/input.mol&#39;</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromMolBlock</span><span class="p">(</span><span class="n">stringWithMolData</span><span class="p">)</span>
</pre></div>
</div>
<p>All of these functions return a <code class="docutils literal"><span class="pre">rdkit.Chem.rdchem.Mol</span></code> object on success:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;rdkit.Chem.rdchem.Mol object at 0x...&gt;</span>
</pre></div>
</div>
<p>or None on failure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromMolFile</span><span class="p">(</span><span class="s1">&#39;data/invalid.mol&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An attempt is made to provide sensible error messages:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CO(C)C&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>displays a message like: <code class="docutils literal"><span class="pre">[12:18:01]</span> <span class="pre">Explicit</span> <span class="pre">valence</span> <span class="pre">for</span> <span class="pre">atom</span> <span class="pre">#</span> <span class="pre">1</span> <span class="pre">O</span> <span class="pre">greater</span> <span class="pre">than</span> <span class="pre">permitted</span></code> and</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1cc1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>displays something like: <code class="docutils literal"><span class="pre">[12:20:41]</span> <span class="pre">Can't</span> <span class="pre">kekulize</span> <span class="pre">mol</span></code>. In each case the value <code class="docutils literal"><span class="pre">None</span></code> is returned:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-sets-of-molecules">
<h3>Reading sets of molecules<a class="headerlink" href="#reading-sets-of-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Groups of molecules are read using a Supplier (for example, an <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolfiles.SDMolSupplier</span></code> or a <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolfiles.SmilesMolSupplier</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/5ht3ligs.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">suppl</span><span class="p">:</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">20</span>
<span class="go">24</span>
<span class="go">24</span>
<span class="go">26</span>
</pre></div>
</div>
<p>You can easily produce lists of molecules from a Supplier:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">suppl</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>or just treat the Supplier itself as a random-access object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suppl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span>
<span class="go">20</span>
</pre></div>
</div>
<p>A good practice is to test each molecule to see if it was correctly read before working with it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/5ht3ligs.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">suppl</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">20</span>
<span class="go">24</span>
<span class="go">24</span>
<span class="go">26</span>
</pre></div>
</div>
<p>An alternate type of Supplier, the <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolfiles.ForwardSDMolSupplier</span></code> can be used to read from file-like objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data/5ht3ligs.sdf&#39;</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fsuppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">ForwardSDMolSupplier</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">fsuppl</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">20</span>
<span class="go">24</span>
<span class="go">24</span>
<span class="go">26</span>
</pre></div>
</div>
<p>This means that they can be used to read from compressed files:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gzip</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inf</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;data/actives_5ht3.sdf.gz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gzsuppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">ForwardSDMolSupplier</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gzsuppl</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
<span class="go">180</span>
</pre></div>
</div>
<p>Note that ForwardSDMolSuppliers cannot be used as random-access objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fsuppl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;ForwardSDMolSupplier&#39; object does not support indexing</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-molecules">
<h3>Writing molecules<a class="headerlink" href="#writing-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Single molecules can be converted to text using several functions present in the <a class="reference external" href="api/rdkit.Chem-module.html">rdkit.Chem</a> module.</p>
<p>For example, for SMILES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromMolFile</span><span class="p">(</span><span class="s1">&#39;data/chiral.mol&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&#39;CC(O)c1ccccc1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;C[C@H](O)c1ccccc1&#39;</span>
</pre></div>
</div>
<p>Note that the SMILES provided is canonical, so the output should be the same no matter how a particular molecule is input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1=CC=CN=C1&#39;</span><span class="p">))</span>
<span class="go">&#39;c1ccncc1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1cccnc1&#39;</span><span class="p">))</span>
<span class="go">&#39;c1ccncc1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;n1ccccc1&#39;</span><span class="p">))</span>
<span class="go">&#39;c1ccncc1&#39;</span>
</pre></div>
</div>
<p>If you’d like to have the Kekule form of the SMILES, first Kekulize the molecule, then use the “kekuleSmiles” option:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">kekuleSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;CC(O)C1=CC=CC=C1&#39;</span>
</pre></div>
</div>
<p>Note: as of this writing (Aug 2008), the smiles provided when one requests kekuleSmiles are not canonical.
The limitation is not in the SMILES generation, but in the kekulization itself.</p>
<p>MDL Mol blocks are also available:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1CCC1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToMolBlock</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span>    

<span class="go">     RDKit</span>

<span class="go">  4  4  0  0  0  0  0  0  0  0999 V2000</span>
<span class="go">    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">  1  2  1  0</span>
<span class="go">  2  3  1  0</span>
<span class="go">  3  4  1  0</span>
<span class="go">  4  1  1  0</span>
<span class="go">M  END</span>
</pre></div>
</div>
<p>To include names in the mol blocks, set the molecule’s “_Name” property:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">,</span><span class="s2">&quot;cyclobutane&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToMolBlock</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span>     
<span class="go">cyclobutane</span>
<span class="go">     RDKit</span>

<span class="go">  4  4  0  0  0  0  0  0  0  0999 V2000</span>
<span class="go">    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.0000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">  1  2  1  0</span>
<span class="go">  2  3  1  0</span>
<span class="go">  3  4  1  0</span>
<span class="go">  4  1  1  0</span>
<span class="go">M  END</span>
</pre></div>
</div>
<p>In order for atom or bond stereochemistry to be recognised correctly by most
software, it’s essential that the Mol block have atomic coordinates.
It’s also convenient for many reasons, such as drawing the molecules.
Coordinates can be generated using functionality in the
<a class="reference external" href="api/rdkit.Chem.AllChem-module.html">rdkit.Chem.AllChem</a> module (see the <a class="reference internal" href="#chem-vs-allchem">Chem vs AllChem</a> section for
more information).</p>
<p>You can either include 2D coordinates (i.e. a depiction):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AllChem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToMolBlock</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span>     
<span class="go">cyclobutane</span>
<span class="go">     RDKit          2D</span>

<span class="go">  4  4  0  0  0  0  0  0  0  0999 V2000</span>
<span class="go">    1.0607   -0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">   -0.0000   -1.0607    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">   -1.0607    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.0000    1.0607    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">  1  2  1  0</span>
<span class="go">  2  3  1  0</span>
<span class="go">  3  4  1  0</span>
<span class="go">  4  1  1  0</span>
<span class="go">M  END</span>
</pre></div>
</div>
<p>Or you can add 3D coordinates by embedding the molecule (we’re using the ETKDG
method here, which is described in more detail below):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMolecule</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span><span class="n">AllChem</span><span class="o">.</span><span class="n">ETKDG</span><span class="p">())</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToMolBlock</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span>    
<span class="go">cyclobutane</span>
<span class="go">     RDKit          3D</span>

<span class="go">  4  4  0  0  0  0  0  0  0  0999 V2000</span>
<span class="go">   -0.8321    0.5405   -0.1981 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">   -0.3467   -0.8825   -0.2651 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.7190   -0.5613    0.7314 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.4599    0.9032    0.5020 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">  1  2  1  0</span>
<span class="go">  2  3  1  0</span>
<span class="go">  3  4  1  0</span>
<span class="go">  4  1  1  0</span>
<span class="go">M  END</span>
</pre></div>
</div>
<p>To get good 3D conformations, it’s almost always a good idea to add
hydrogens to the molecule first:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m3</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMolecule</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span><span class="n">AllChem</span><span class="o">.</span><span class="n">ETKDG</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
<p>These can then be removed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m3</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveHs</span><span class="p">(</span><span class="n">m3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToMolBlock</span><span class="p">(</span><span class="n">m3</span><span class="p">))</span>    
<span class="go">cyclobutane</span>
<span class="go">     RDKit          3D</span>

<span class="go">  4  4  0  0  0  0  0  0  0  0999 V2000</span>
<span class="go">    0.3497    0.9755   -0.2202 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    0.9814   -0.3380    0.2534 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">   -0.3384   -1.0009   -0.1474 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">   -0.9992    0.3532    0.1458 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">  1  2  1  0</span>
<span class="go">  2  3  1  0</span>
<span class="go">  3  4  1  0</span>
<span class="go">  4  1  1  0</span>
<span class="go">M  END</span>
</pre></div>
</div>
<p>If you’d like to write the molecules to a file, use Python file objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToMolBlock</span><span class="p">(</span><span class="n">m2</span><span class="p">),</span><span class="n">file</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data/foo.mol&#39;</span><span class="p">,</span><span class="s1">&#39;w+&#39;</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-sets-of-molecules">
<h3>Writing sets of molecules<a class="headerlink" href="#writing-sets-of-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Multiple molecules can be written to a file using an <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolfiles.SDWriter</span></code> object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDWriter</span><span class="p">(</span><span class="s1">&#39;data/foo.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mols</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>An SDWriter can also be initialized using a file-like object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.six</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDWriter</span><span class="p">(</span><span class="n">sio</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mols</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
<span class="go">mol-295</span>
<span class="go">     RDKit          3D</span>

<span class="go"> 20 22  0  0  1  0  0  0  0  0999 V2000</span>
<span class="go">    2.3200    0.0800   -0.1000 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">    1.8400   -1.2200    0.1200 C   0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="gp">...</span>
<span class="go">  1  3  1  0</span>
<span class="go">  1  4  1  0</span>
<span class="go">  2  5  1  0</span>
<span class="go">M  END</span>
<span class="go">$$$$</span>
</pre></div>
</div>
<p>Other available Writers include the <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolfiles.SmilesWriter</span></code> and the <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolfiles.TDTWriter</span></code>.</p>
</div>
</div>
<div class="section" id="working-with-molecules">
<h2>Working with Molecules<a class="headerlink" href="#working-with-molecules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="looping-over-atoms-and-bonds">
<h3>Looping over Atoms and Bonds<a class="headerlink" href="#looping-over-atoms-and-bonds" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Once you have a molecule, it’s easy to loop over its atoms and bonds:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1OC1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">6</span>
<span class="go">8</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">())</span>
<span class="go">SINGLE</span>
</pre></div>
</div>
<p>You can also request individual bonds or atoms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetExplicitValence</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span>
<span class="go">rdkit.Chem.rdchem.BondType.SINGLE</span>
</pre></div>
</div>
<p>Atoms keep track of their neighbors:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()]</span>
<span class="go">[8, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
</div>
<div class="section" id="ring-information">
<h3>Ring Information<a class="headerlink" href="#ring-information" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Atoms and bonds both carry information about the molecule’s rings:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OC1C2C1CC2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">IsInRing</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">IsInRing</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">IsInRingSize</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">IsInRingSize</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">IsInRingSize</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">IsInRingSize</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">IsInRing</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But note that the information is only about the smallest rings:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">IsInRingSize</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>More detail about the smallest set of smallest rings (SSSR) is available:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssr</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetSymmSSSR</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ssr</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">ssr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">ssr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[4, 5, 2, 3]</span>
</pre></div>
</div>
<p>As the name indicates, this is a symmetrized SSSR; if you are interested in the number of “true” SSSR, use the GetSSSR function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">GetSSSR</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The distinction between symmetrized and non-symmetrized SSSR is discussed in more detail below in the section <a class="reference internal" href="#the-sssr-problem">The SSSR Problem</a>.</p>
<p>For more efficient queries about a molecule’s ring systems (avoiding repeated calls to Mol.GetAtomWithIdx), use the <code class="docutils literal"><span class="pre">rdkit.Chem.rdchem.RingInfo</span></code> class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OC1C2C1CC2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">GetRingInfo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">NumAtomRings</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">NumAtomRings</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">NumAtomRings</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">IsAtomInRingOfSize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">IsBondInRingOfSize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="modifying-molecules">
<h3>Modifying molecules<a class="headerlink" href="#modifying-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Normally molecules are stored in the RDKit with the hydrogen atoms implicit (e.g. not explicitly present in the molecular graph.
When it is useful to have the hydrogens explicitly present, for example when generating or optimizing the 3D geometry, the <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolops.AddHs</span></code> function can be used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">=</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CCO&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span>
<span class="go">9</span>
</pre></div>
</div>
<p>The Hs can be removed again using the <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolops.RemoveHs</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m3</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveHs</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m3</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>RDKit molecules are usually stored with the bonds in aromatic rings having aromatic bond types.
This can be changed with the <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolops.Kekulize</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span>
<span class="go">rdkit.Chem.rdchem.BondType.AROMATIC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span>
<span class="go">rdkit.Chem.rdchem.BondType.DOUBLE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span>
<span class="go">rdkit.Chem.rdchem.BondType.SINGLE</span>
</pre></div>
</div>
<p>By default, the bonds are still marked as being aromatic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>because the flags in the original molecule are not cleared (clearAromaticFlags defaults to False).
You can explicitly force or decline a clearing of the flags:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">clearAromaticFlags</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Bonds can be restored to the aromatic bond type using the <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolops.SanitizeMol</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">rdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_NONE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span>
<span class="go">rdkit.Chem.rdchem.BondType.AROMATIC</span>
</pre></div>
</div>
<p>The value returned by <cite>SanitizeMol()</cite> indicates that no problems were encountered.</p>
</div>
<div class="section" id="working-with-2d-molecules-generating-depictions">
<h3>Working with 2D molecules: Generating Depictions<a class="headerlink" href="#working-with-2d-molecules-generating-depictions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The RDKit has a library for generating depictions (sets of 2D) coordinates for molecules.
This library, which is part of the AllChem module, is accessed using the <code class="docutils literal"><span class="pre">rdkit.Chem.rdDepictor.Compute2DCoords</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1nccc2n1ccc2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The 2D conformation is constructed in a canonical orientation and is
built to minimize intramolecular clashes, i.e. to maximize the clarity
of the drawing.</p>
<p>If you have a set of molecules that share a common template and you’d
like to align them to that template, you can do so as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">template</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1nccc2n1ccc2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">GenerateDepictionMatching2DStructure</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">template</span><span class="p">)</span>
</pre></div>
</div>
<p>Running this process for a couple of other molecules gives the
following depictions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="_images/picture_1.png"><img alt="picture_1" src="_images/picture_1.png" style="width: 225.0px; height: 225.0px;" /></a></td>
<td><a class="reference internal" href="_images/picture_0.png"><img alt="picture_0" src="_images/picture_0.png" style="width: 225.0px; height: 225.0px;" /></a></td>
<td><a class="reference internal" href="_images/picture_3.png"><img alt="picture_3" src="_images/picture_3.png" style="width: 225.0px; height: 225.0px;" /></a></td>
</tr>
</tbody>
</table>
<p>Another option for Compute2DCoords allows you to generate 2D depictions for molecules that closely mimic 3D conformations.
This is available using the function <a class="reference external" href="api/rdkit.Chem.AllChem-module.html#GenerateDepictionMatching3DStructure">GenerateDepictionMatching3DStructure</a>.</p>
<p>Here is an illustration of the results using the ligand from PDB structure 1XP0:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="_images/picture_2.png"><img alt="picture_2" src="_images/picture_2.png" style="width: 320.0px; height: 240.0px;" /></a></td>
<td><a class="reference internal" href="_images/picture_4.png"><img alt="picture_4" src="_images/picture_4.png" style="width: 225.0px; height: 225.0px;" /></a></td>
</tr>
</tbody>
</table>
<p>More fine-grained control can be obtained using the core function
<code class="docutils literal"><span class="pre">rdkit.Chem.rdDepictor.Compute2DCoordsMimicDistmat</span></code>, but that is
beyond the scope of this document.  See the implementation of
GenerateDepictionMatching3DStructure in AllChem.py for an example of
how it is used.</p>
</div>
<div class="section" id="working-with-3d-molecules">
<h3>Working with 3D Molecules<a class="headerlink" href="#working-with-3d-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The RDKit can generate conformations for molecules using two different
methods.  The original method used distance geometry. <a class="footnote-reference" href="#blaney" id="id1">[1]</a>
The algorithm followed is:</p>
<ol class="arabic simple">
<li>The molecule’s distance bounds matrix is calculated based on the connection table and a set of rules.</li>
<li>The bounds matrix is smoothed using a triangle-bounds smoothing algorithm.</li>
<li>A random distance matrix that satisfies the bounds matrix is generated.</li>
<li>This distance matrix is embedded in 3D dimensions (producing coordinates for each atom).</li>
<li>The resulting coordinates are cleaned up somewhat using a crude force field and the bounds matrix.</li>
</ol>
<p>Note that the conformations that result from this procedure tend to be fairly ugly.
They should be cleaned up using a force field.
This can be done within the RDKit using its implementation of the Universal Force Field (UFF). <a class="footnote-reference" href="#rappe" id="id2">[2]</a></p>
<p>More recently, there is an implementation of the method of Riniker and
Landrum <a class="footnote-reference" href="#riniker2" id="id3">[18]</a> which uses torsion angle preferences from the
Cambridge Structural Database (CSD) to correct the conformers after
distance geometry has been used to generate them.  With this method,
there should be no need to use a minimisation step to clean up the
structures.</p>
<p>The full process of embedding and optimizing a molecule is easier than all the above verbiage makes it sound:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1CCC1OC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">=</span><span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># use the original distance geometry + minimisation method</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMolecule</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">UFFOptimizeMolecule</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m3</span><span class="o">=</span><span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># use the new method</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMolecule</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ETKDG</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The RDKit also has an implementation of the MMFF94 force field available. <a class="footnote-reference" href="#mmff1" id="id4">[12]</a>, <a class="footnote-reference" href="#mmff2" id="id5">[13]</a>, <a class="footnote-reference" href="#mmff3" id="id6">[14]</a>, <a class="footnote-reference" href="#mmff4" id="id7">[15]</a>, <a class="footnote-reference" href="#mmffs" id="id8">[16]</a>
Please note that the MMFF atom typing code uses its own aromaticity model,
so the aromaticity flags of the molecule will be modified after calling
MMFF-related methods.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1CCC1OC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">=</span><span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMolecule</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">MMFFOptimizeMolecule</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Note the calls to <cite>Chem.AddHs()</cite> in the examples above. By default
RDKit molecules do not have H atoms explicitly present in the graph,
but they are important for getting realistic geometries, so they
generally should be added.  They can always be removed afterwards
if necessary with a call to <cite>Chem.RemoveHs()</cite>.</p>
<p>With the RDKit, multiple conformers can also be generated using the two
different embedding methods. In both cases this is simply a matter of
running the distance geometry calculation multiple times from
different random start points. The option numConfs allows the user to
set the number of conformers that should be generated.  Otherwise the
procedures are as before. The conformers so generated can be aligned
to each other and the RMS values calculated.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1CCC1OC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">=</span><span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># run distance geometry 10 times</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cids</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMultipleConfs</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">numConfs</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cids</span><span class="p">))</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cids</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">MMFFOptimizeMolecule</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">confId</span><span class="o">=</span><span class="n">cid</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rmslist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">AlignMolConformers</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">RMSlist</span><span class="o">=</span><span class="n">rmslist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rmslist</span><span class="p">))</span>
<span class="go">9</span>
</pre></div>
</div>
<p>rmslist contains the RMS values between the first conformer and all others.
The RMS between two specific conformers (e.g. 1 and 9) can also be calculated.
The flag prealigned lets the user specify if the conformers are already aligned
(by default, the function aligns them).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rms</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetConformerRMS</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">prealigned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also generate multiple conformers using the new CSD-based method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1CCC1OC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m3</span><span class="o">=</span><span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># run the new CSD-based method</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cids</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMultipleConfs</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ETKDG</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cids</span><span class="p">))</span>
<span class="go">10</span>
</pre></div>
</div>
<p>More 3D functionality of the RDKit is described in the Cookbook.</p>
<p><em>Disclaimer/Warning</em>: Conformation generation is a difficult and subtle task.
The original, default, 2D-&gt;3D conversion provided with the RDKit is not intended
to be a replacement for a “real” conformational analysis tool; it
merely provides quick 3D structures for cases when they are
required. We believe, however, that the newer ETKDG method[#riniker2]_ should be
adequate for most purposes.</p>
</div>
<div class="section" id="preserving-molecules">
<h3>Preserving Molecules<a class="headerlink" href="#preserving-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Molecules can be converted to and from text using Python’s pickling machinery:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccncc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pkl</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pkl</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="go">&#39;c1ccncc1&#39;</span>
</pre></div>
</div>
<p>The RDKit pickle format is fairly compact and it is much, much faster to build a molecule from a pickle than from a Mol file or SMILES string, so storing molecules you will be working with repeatedly as pickles can be a good idea.</p>
<p>The raw binary data that is encapsulated in a pickle can also be directly obtained from a molecule:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binStr</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ToBinary</span><span class="p">()</span>
</pre></div>
</div>
<p>This can be used to reconstruct molecules using the Chem.Mol constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">(</span><span class="n">binStr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="go">&#39;c1ccncc1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">binStr</span><span class="p">)</span>
<span class="go">123</span>
</pre></div>
</div>
<p>Note that this is smaller than the pickle:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">binStr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pkl</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The small overhead associated with python’s pickling machinery normally doesn’t end up making much of a difference for collections of larger molecules (the extra data associated with the pickle is independent of the size of the molecule, while the binary string increases in length as the molecule gets larger).</p>
<p><em>Tip</em>: The performance difference associated with storing molecules in a pickled form on disk instead of constantly reparsing an SD file or SMILES table is difficult to overstate.
In a test I just ran on my laptop, loading a set of 699 drug-like molecules from an SD file took 10.8 seconds; loading the same molecules from a pickle file took 0.7 seconds.
The pickle file is also smaller – 1/3 the size of the SD file – but this difference is not always so dramatic (it’s a particularly fat SD file).</p>
</div>
<div class="section" id="drawing-molecules">
<h3>Drawing Molecules<a class="headerlink" href="#drawing-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The RDKit has some built-in functionality for creating images from
molecules found in the <a class="reference external" href="api/rdkit.Chem.Draw-module.html">rdkit.Chem.Draw</a> package:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/cdk2.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">suppl</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">:</span> <span class="n">tmp</span><span class="o">=</span><span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">Draw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Draw</span><span class="o">.</span><span class="n">MolToFile</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;images/cdk2_mol1.o.png&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Draw</span><span class="o">.</span><span class="n">MolToFile</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;images/cdk2_mol2.o.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Producing these images:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><img alt="_images/cdk2_mol1.png" class="first last" src="_images/cdk2_mol1.png" />
</td>
<td><img alt="_images/cdk2_mol2.png" class="first last" src="_images/cdk2_mol2.png" />
</td>
</tr>
</tbody>
</table>
<p>It’s also possible to produce an image grid out of a set of molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">=</span><span class="n">Draw</span><span class="o">.</span><span class="n">MolsToGridImage</span><span class="p">(</span><span class="n">ms</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span><span class="n">molsPerRow</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">subImgSize</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">),</span><span class="n">legends</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">[:</span><span class="mi">8</span><span class="p">]])</span>
</pre></div>
</div>
<p>This returns a PIL image, which can then be saved to a file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;images/cdk2_molgrid.o.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The result looks like this:</p>
<img alt="_images/cdk2_molgrid.png" src="_images/cdk2_molgrid.png" />
<p>These would of course look better if the common core were
aligned. This is easy enough to do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;[nH]1cnc2cncnc21&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ms</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">subms</span><span class="p">)</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">subms</span><span class="p">:</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GenerateDepictionMatching2DStructure</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">=</span><span class="n">Draw</span><span class="o">.</span><span class="n">MolsToGridImage</span><span class="p">(</span><span class="n">subms</span><span class="p">,</span><span class="n">molsPerRow</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">subImgSize</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">),</span><span class="n">legends</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">subms</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;images/cdk2_molgrid.aligned.o.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The result looks like this:</p>
<img alt="_images/cdk2_molgrid_aligned.png" src="_images/cdk2_molgrid_aligned.png" />
</div>
</div>
<div class="section" id="substructure-searching">
<h2>Substructure Searching<a class="headerlink" href="#substructure-searching" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Substructure matching can be done using query molecules built from SMARTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patt</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;ccO&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">patt</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetSubstructMatch</span><span class="p">(</span><span class="n">patt</span><span class="p">)</span>
<span class="go">(0, 5, 6)</span>
</pre></div>
</div>
<p>Those are the atom indices in <code class="docutils literal"><span class="pre">m</span></code>, ordered as <code class="docutils literal"><span class="pre">patt</span></code>’s atoms. To get all of the matches:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">patt</span><span class="p">)</span>
<span class="go">((0, 5, 6), (4, 5, 6))</span>
</pre></div>
</div>
<p>This can be used to easily filter lists of molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/actives_5ht3.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patt</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;c[NH1]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">suppl</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">patt</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
<span class="go">22</span>
</pre></div>
</div>
<p>We can write the same thing more compactly using Python’s list comprehension syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">suppl</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">patt</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>
<span class="go">22</span>
</pre></div>
</div>
<p>Substructure matching can also be done using molecules built from SMILES instead of SMARTS:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1=CC=CC=C1OC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;CO&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CO&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But don’t forget that the semantics of the two languages are not exactly equivalent:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;COC&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;COC&#39;</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;COc&#39;</span><span class="p">))</span> <span class="c1">#&lt;- need an aromatic C</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="section" id="stereochemistry-in-substructure-matches">
<h3>Stereochemistry in substructure matches<a class="headerlink" href="#stereochemistry-in-substructure-matches" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By default information about stereochemistry is not used in
substructure searches:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC[C@H](F)Cl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C[C@H](F)Cl&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C[C@@H](F)Cl&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(F)Cl&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But this can be changed via the <cite>useChirality</cite> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C[C@H](F)Cl&#39;</span><span class="p">),</span><span class="n">useChirality</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C[C@@H](F)Cl&#39;</span><span class="p">),</span><span class="n">useChirality</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(F)Cl&#39;</span><span class="p">),</span><span class="n">useChirality</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Notice that when <cite>useChirality</cite> is set a non-chiral query <strong>does</strong> match a chiral
molecule. The same is not true for a chiral query and a non-chiral molecule:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(F)Cl&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CCC(F)Cl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">HasSubstructMatch</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C[C@H](F)Cl&#39;</span><span class="p">),</span><span class="n">useChirality</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="atom-map-indices-in-smarts">
<h3>Atom Map Indices in SMARTS<a class="headerlink" href="#atom-map-indices-in-smarts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>It is possible to attach indices to the atoms in the SMARTS
pattern. This is most often done in reaction SMARTS (see <a class="reference internal" href="#chemical-reactions">Chemical
Reactions</a>), but is more general than that.  For example, in the
SMARTS patterns for torsion angle analysis published by Guba <cite>et al.</cite>
(<code class="docutils literal"><span class="pre">DOI:</span> <span class="pre">acs.jcim.5b00522</span></code>) indices are used to define the four atoms of
the torsion of interest. This allows additional atoms to be used to
define the environment of the four torsion atoms, as in
<code class="docutils literal"><span class="pre">[cH0:1][c:2]([cH0])!&#64;[CX3!r:3]=[NX2!r:4]</span></code> for an aromatic C=N
torsion.  We might wonder in passing why they didn’t use
recursive SMARTS for this, which would have made life easier, but it
is what it is. The atom lists from <code class="docutils literal"><span class="pre">GetSubstructureMatches</span></code> are
guaranteed to be in order of the SMARTS, but in this case we’ll get five
atoms so we need a way of picking out, in the correct order, the four of
interest.  When the SMARTS is parsed, the relevant atoms are assigned an
atom map number property that we can easily extract:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span> <span class="s1">&#39;[cH0:1][c:2]([cH0])!@[CX3!r:3]=[NX2!r:4]&#39;</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">qmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()</span> <span class="p">:</span>
<span class="gp">... </span>    <span class="n">map_num</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">map_num</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">ind_map</span><span class="p">[</span><span class="n">map_num</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind_map</span>
<span class="go">{0: 0, 1: 1, 2: 3, 3: 4}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind_map</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ind_map</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_list</span>
<span class="go">[0, 1, 3, 4]</span>
</pre></div>
</div>
<p>Then, when using the query on a molecule you can get the indices of the four
matching atoms like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;Cc1cccc(C)c1C(C)=NC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span> <span class="n">qmol</span> <span class="p">)</span> <span class="p">:</span>
<span class="gp">... </span>    <span class="n">mas</span> <span class="o">=</span> <span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">map_list</span><span class="p">]</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">mas</span><span class="p">)</span>
<span class="go">[1, 7, 8, 10]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="chemical-transformations">
<h2>Chemical Transformations<a class="headerlink" href="#chemical-transformations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The RDKit contains a number of functions for modifying molecules. Note
that these transformation functions are intended to provide an easy
way to make simple modifications to molecules.
For more complex transformations, use the <a class="reference internal" href="#chemical-reactions">Chemical Reactions</a> functionality.</p>
<div class="section" id="substructure-based-transformations">
<h3>Substructure-based transformations<a class="headerlink" href="#substructure-based-transformations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>There’s a variety of functionality for using the RDKit’s
substructure-matching machinery for doing quick molecular transformations.
These transformations include deleting substructures:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(=O)O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patt</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;C(=O)[OH]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rm</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">DeleteSubstructs</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">patt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
<span class="go">&#39;C&#39;</span>
</pre></div>
</div>
<p>replacing substructures:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">repl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patt</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;[$(NC(=O))]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(=O)N&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rms</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReplaceSubstructs</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">patt</span><span class="p">,</span><span class="n">repl</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rms</span>
<span class="go">(&lt;rdkit.Chem.rdchem.Mol object at 0x...&gt;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">rms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;COC(C)=O&#39;</span>
</pre></div>
</div>
<p>as well as simple SAR-table transformations like removing side chains:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;BrCCc1cncnc1C(=O)O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">core</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1cncnc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">ReplaceSidechains</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="n">core</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
<span class="go">&#39;[*]c1cncnc1[*]&#39;</span>
</pre></div>
</div>
<p>and removing cores:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">ReplaceCore</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="n">core</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
<span class="go">&#39;[*]C(=O)O.[*]CCBr&#39;</span>
</pre></div>
</div>
<p>To get more detail about the sidechains (e.g. sidechain labels), use isomeric smiles:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;[1*]CCBr.[2*]C(=O)O&#39;</span>
</pre></div>
</div>
<p>By default the sidechains are labeled based on the order they are found.
They can also be labeled according by the number of that core-atom they’re attached to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1c(CCO)ncnc1C(=O)O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span><span class="o">=</span><span class="n">Chem</span><span class="o">.</span><span class="n">ReplaceCore</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="n">core</span><span class="p">,</span><span class="n">labelByIndex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;[1*]CCO.[5*]C(=O)O&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">rdkit.Chem.rdmolops.ReplaceCore</span></code> returns the sidechains in a single molecule.
This can be split into separate molecules using <code class="docutils literal"><span class="pre">rdkit.Chem.rdmolops.GetMolFrags</span></code> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rs</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">asMols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;[1*]CCO&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;[5*]C(=O)O&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="murcko-decomposition">
<h3>Murcko Decomposition<a class="headerlink" href="#murcko-decomposition" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The RDKit provides standard Murcko-type decomposition <a class="footnote-reference" href="#bemis1" id="id9">[7]</a> of molecules
into scaffolds:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.Scaffolds</span> <span class="k">import</span> <span class="n">MurckoScaffold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdk2mols</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/cdk2.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">cdk2mols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">core</span> <span class="o">=</span> <span class="n">MurckoScaffold</span><span class="o">.</span><span class="n">GetScaffoldForMol</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>
<span class="go">&#39;c1ncc2nc[nH]c2n1&#39;</span>
</pre></div>
</div>
<p>or into a generic framework:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fw</span> <span class="o">=</span> <span class="n">MurckoScaffold</span><span class="o">.</span><span class="n">MakeScaffoldGeneric</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">fw</span><span class="p">)</span>
<span class="go">&#39;C1CCC2CCCC2C1&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="maximum-common-substructure">
<h2>Maximum Common Substructure<a class="headerlink" href="#maximum-common-substructure" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The FindMCS function find a maximum common substructure (MCS) of two
or more molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">rdFMCS</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;O=C(NCc1cc(OC)c(O)cc1)CCCC/C=C/C(C)C&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;CC(C)CCCCCC(=O)NCC1=CC(=C(C=C1)O)OC&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol3</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;c1(C=O)cc(OC)c(O)cc1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol2</span><span class="p">,</span><span class="n">mol3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">=</span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span>
<span class="go">&lt;rdkit.Chem.rdFMCS.MCSResult object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">numAtoms</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">numBonds</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6]1(-[#6]):[#6]:[#6](-[#8]-[#6]):[#6](:[#6]:[#6]:1)-[#8]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">canceled</span>
<span class="go">False</span>
</pre></div>
</div>
<p>It returns an MCSResult instance with information about the number of
atoms and bonds in the MCS, the SMARTS string which matches the
identified MCS, and a flag saying if the algorithm timed out. If no
MCS is found then the number of atoms and bonds is set to 0 and the
SMARTS to <code class="docutils literal"><span class="pre">''</span></code>.</p>
<p>By default, two atoms match if they are the same element and two bonds
match if they have the same bond type. Specify <code class="docutils literal"><span class="pre">atomCompare</span></code> and
<code class="docutils literal"><span class="pre">bondCompare</span></code> to use different comparison functions, as in:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mols</span> <span class="o">=</span> <span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;NCC&#39;</span><span class="p">),</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OC=C&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span> <span class="n">atomCompare</span><span class="o">=</span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">AtomCompare</span><span class="o">.</span><span class="n">CompareAny</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#7,#8]-[#6]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span> <span class="n">bondCompare</span><span class="o">=</span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">BondCompare</span><span class="o">.</span><span class="n">CompareAny</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6]-,=[#6]&#39;</span>
</pre></div>
</div>
<p>The options for the atomCompare argument are: CompareAny says that any
atom matches any other atom, CompareElements compares by element type,
and CompareIsotopes matches based on the isotope label. Isotope labels
can be used to implement user-defined atom types. A bondCompare of
CompareAny says that any bond matches any other bond, CompareOrderExact says
bonds are equivalent if and only if they have the same bond type, and
CompareOrder allows single and aromatic bonds to match each other, but
requires an exact order match otherwise:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mols</span> <span class="o">=</span> <span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1&#39;</span><span class="p">),</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1CCCC=C1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span><span class="n">bondCompare</span><span class="o">=</span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">BondCompare</span><span class="o">.</span><span class="n">CompareAny</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6]1:,-[#6]:,-[#6]:,-[#6]:,-[#6]:,=[#6]:,-1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span><span class="n">bondCompare</span><span class="o">=</span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">BondCompare</span><span class="o">.</span><span class="n">CompareOrderExact</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span><span class="n">bondCompare</span><span class="o">=</span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">BondCompare</span><span class="o">.</span><span class="n">CompareOrder</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6](:,-[#6]:,-[#6]:,-[#6]):,-[#6]:,-[#6]&#39;</span>
</pre></div>
</div>
<p>A substructure has both atoms and bonds. By default, the algorithm
attempts to maximize the number of bonds found. You can change this by
setting the <code class="docutils literal"><span class="pre">maximizeBonds</span></code> argument to False.
Maximizing the number of bonds tends to maximize the number of rings,
although two small rings may have fewer bonds than one large ring.</p>
<p>You might not want a 3-valent nitrogen to match one which is 5-valent.
The default <code class="docutils literal"><span class="pre">matchValences</span></code> value of False ignores valence
information.  When True, the atomCompare setting is modified to also
require that the two atoms have the same valency.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mols</span> <span class="o">=</span> <span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;NC1OC1&#39;</span><span class="p">),</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1OC1[N+](=O)[O-]&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span><span class="o">.</span><span class="n">numAtoms</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span> <span class="n">matchValences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">numBonds</span>
<span class="go">3</span>
</pre></div>
</div>
<p>It can be strange to see a linear carbon chain match a carbon ring,
which is what the <code class="docutils literal"><span class="pre">ringMatchesRingOnly</span></code> default of False does. If
you set it to True then ring bonds will only match ring bonds.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;C1CCC1CCC&quot;</span><span class="p">),</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;C1CCCCCC1&quot;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6](-[#6]-[#6])-[#6]-[#6]-[#6]-[#6]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span> <span class="n">ringMatchesRingOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6](-[#6]-[#6])-[#6]&#39;</span>
</pre></div>
</div>
<p>You can further restrict things and require that partial rings (as in
this case) are not allowed. That is, if an atom is part of the MCS and
the atom is in a ring of the entire molecule then that atom is also in
a ring of the MCS. Set <code class="docutils literal"><span class="pre">completeRingsOnly</span></code> to True to toggle this
requirement and also sets ringMatchesRingOnly to True.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;CCC1CC2C1CN2&quot;</span><span class="p">),</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;C1CC2C1CC2&quot;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6]1-[#6]-[#6](-[#6]-1-[#6])-[#6]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span> <span class="n">ringMatchesRingOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6](-[#6]-[#6]-[#6]-[#6])-[#6]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span> <span class="n">completeRingsOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">smartsString</span>
<span class="go">&#39;[#6]1-[#6]-[#6]-[#6]-1&#39;</span>
</pre></div>
</div>
<p>The MCS algorithm will exhaustively search for a maximum common substructure.
Typically this takes a fraction of a second, but for some comparisons this
can take minutes or longer. Use the <code class="docutils literal"><span class="pre">timeout</span></code> parameter to stop the search
after the given number of seconds (wall-clock seconds, not CPU seconds) and
return the best match found in that time. If timeout is reached then the
<code class="docutils literal"><span class="pre">canceled</span></code> property of the MCSResult will be True instead of False.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mols</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;Nc1ccccc1&quot;</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s2">&quot;Nc1ccccccccc1&quot;</span><span class="o">*</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdFMCS</span><span class="o">.</span><span class="n">FindMCS</span><span class="p">(</span><span class="n">mols</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">canceled</span>
<span class="go">True</span>
</pre></div>
</div>
<p>(The MCS after 50 seconds contained 511 atoms.)</p>
</div>
<div class="section" id="fingerprinting-and-molecular-similarity">
<h2>Fingerprinting and Molecular Similarity<a class="headerlink" href="#fingerprinting-and-molecular-similarity" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The RDKit has a variety of built-in functionality for generating molecular fingerprints and using them to calculate molecular similarity.</p>
<div class="section" id="topological-fingerprints">
<h3>Topological Fingerprints<a class="headerlink" href="#topological-fingerprints" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">DataStructs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.Fingerprints</span> <span class="k">import</span> <span class="n">FingerprintMols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CCOC&#39;</span><span class="p">),</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CCO&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;COC&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fps</span> <span class="o">=</span> <span class="p">[</span><span class="n">FingerprintMols</span><span class="o">.</span><span class="n">FingerprintMol</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">FingerprintSimilarity</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fps</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0.6...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">FingerprintSimilarity</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.4...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">FingerprintSimilarity</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.25</span>
</pre></div>
</div>
<p>The fingerprinting algorithm used is similar to that used in the
Daylight fingerprinter: it identifies and hashes topological paths
(e.g. along bonds) in the molecule and then uses them to set bits in a
fingerprint of user-specified lengths. After all paths have been identified, the fingerprint is typically folded down until a particular density of set bits is obtained.</p>
<p>The default set of parameters used by the fingerprinter is:
- minimum path size: 1 bond
- maximum path size: 7 bonds
- fingerprint size: 2048 bits
- number of bits set per hash: 2
- minimum fingerprint size: 64 bits
- target on-bit density 0.3</p>
<p>You can control these by calling
<code class="docutils literal"><span class="pre">rdkit.Chem.rdmolops.RDKFingerprint</span></code> directly; this will return
an unfolded fingerprint that you can then fold to the desired density.
The function
<a class="reference external" href="api/rdkit.Chem.Fingerprints.FingerprintMols-module.html#FingerprintMol">FingerprintMol</a> (written
in python) shows how this is done.</p>
<p>The default similarity metric used by
<a class="reference external" href="api/rdkit.DataStructs-module.html#FingerprintSimilarity">FingerprintSimilarity</a> is the Tanimoto
similarity.  One can use different similarity metrics:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">FingerprintSimilarity</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">)</span>
<span class="go">0.75</span>
</pre></div>
</div>
<p>Available similarity metrics include Tanimoto, Dice, Cosine, Sokal, Russel, Kulczynski, McConnaughey, and Tversky.</p>
</div>
<div class="section" id="maccs-keys">
<h3>MACCS Keys<a class="headerlink" href="#maccs-keys" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>There is a SMARTS-based implementation of the 166 public MACCS keys.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">MACCSkeys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fps</span> <span class="o">=</span> <span class="p">[</span><span class="n">MACCSkeys</span><span class="o">.</span><span class="n">GenMACCSKeys</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">FingerprintSimilarity</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fps</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">FingerprintSimilarity</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.538...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">FingerprintSimilarity</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.214...</span>
</pre></div>
</div>
<p>The MACCS keys were critically evaluated and compared to other MACCS implementations in Q3 2008. In cases where the public keys are fully defined, things looked pretty good.</p>
</div>
<div class="section" id="atom-pairs-and-topological-torsions">
<h3>Atom Pairs and Topological Torsions<a class="headerlink" href="#atom-pairs-and-topological-torsions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Atom-pair descriptors <a class="footnote-reference" href="#carhart" id="id10">[3]</a> are available in several different forms.
The standard form is as fingerprint including counts for each bit instead of just zeros and ones:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.AtomPairs</span> <span class="k">import</span> <span class="n">Pairs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C1CCC1OCC&#39;</span><span class="p">),</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(C)OCC&#39;</span><span class="p">),</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CCOCC&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairFps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pairs</span><span class="o">.</span><span class="n">GetAtomPairFingerprint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
</pre></div>
</div>
<p>Because the space of bits that can be included in atom-pair fingerprints is huge, they are stored in a sparse manner.
We can get the list of bits and their counts for each fingerprint as a dictionary:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">pairFps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">GetNonzeroElements</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">541732</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">1606690</span><span class="p">]</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Descriptions of the bits are also available:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Pairs</span><span class="o">.</span><span class="n">ExplainPairScore</span><span class="p">(</span><span class="mi">558115</span><span class="p">)</span>
<span class="go">((&#39;C&#39;, 1, 0), 3, (&#39;C&#39;, 2, 0))</span>
</pre></div>
</div>
<p>The above means: C with 1 neighbor and 0 pi electrons which is 3 bonds
from a C with 2 neighbors and 0 pi electrons</p>
<p>The usual metric for similarity between atom-pair fingerprints is Dice similarity:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">DataStructs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0.333...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.258...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.56</span>
</pre></div>
</div>
<p>It’s also possible to get atom-pair descriptors encoded as a standard
bit vector fingerprint (ignoring the count information):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pairFps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pairs</span><span class="o">.</span><span class="n">GetAtomPairFingerprintAsBitVect</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
</pre></div>
</div>
<p>Since these are standard bit vectors, the <a class="reference external" href="api/rdkit.DataStructs-module.html">rdkit.DataStructs</a>
module can be used for similarity:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">DataStructs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0.48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.380...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">pairFps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.625</span>
</pre></div>
</div>
<p>Topological torsion descriptors <a class="footnote-reference" href="#nilakantan" id="id11">[4]</a> are calculated in
essentially the same way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.AtomPairs</span> <span class="k">import</span> <span class="n">Torsions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Torsions</span><span class="o">.</span><span class="n">GetTopologicalTorsionFingerprintAsIntVect</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">tts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0.166...</span>
</pre></div>
</div>
<p>At the time of this writing, topological torsion fingerprints have too many bits to be encodeable using the BitVector machinery, so there is no GetTopologicalTorsionFingerprintAsBitVect function.</p>
</div>
<div class="section" id="morgan-fingerprints-circular-fingerprints">
<h3>Morgan Fingerprints (Circular Fingerprints)<a class="headerlink" href="#morgan-fingerprints-circular-fingerprints" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>This family of fingerprints, better known as circular fingerprints
<a class="footnote-reference" href="#rogers" id="id12">[5]</a>, is built by applying the Morgan algorithm to a set of
user-supplied atom invariants.  When generating Morgan fingerprints,
the radius of the fingerprint must also be provided :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AllChem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;Cc1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span>
<span class="go">&lt;rdkit.DataStructs.cDataStructs.UIntSparseIntVect object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;Cc1ncccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp2</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">fp1</span><span class="p">,</span><span class="n">fp2</span><span class="p">)</span>
<span class="go">0.55...</span>
</pre></div>
</div>
<p>Morgan fingerprints, like atom pairs and topological torsions, use
counts by default, but it’s also possible to calculate them as bit
vectors:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprintAsBitVect</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">nBits</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span>
<span class="go">&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp2</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprintAsBitVect</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">nBits</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">fp1</span><span class="p">,</span><span class="n">fp2</span><span class="p">)</span>
<span class="go">0.51...</span>
</pre></div>
</div>
<p>The default atom invariants use connectivity information similar to
those used for the well known ECFP family of fingerprints.
Feature-based invariants, similar to those used for the FCFP
fingerprints, can also be used. The feature definitions used are
defined in the section <a class="reference internal" href="#feature-definitions-used-in-the-morgan-fingerprints">Feature Definitions Used in the Morgan
Fingerprints</a>.  At times this can lead to quite different similarity
scores:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccn1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccco1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp2</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ffp1</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">useFeatures</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ffp2</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">useFeatures</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">fp1</span><span class="p">,</span><span class="n">fp2</span><span class="p">)</span>
<span class="go">0.36...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">ffp1</span><span class="p">,</span><span class="n">ffp2</span><span class="p">)</span>
<span class="go">0.90...</span>
</pre></div>
</div>
<p>When comparing the ECFP/FCFP fingerprints and the Morgan fingerprints
generated by the RDKit, remember that the 4 in ECFP4 corresponds to
the diameter of the atom environments considered, while the Morgan
fingerprints take a radius parameter.  So the examples above, with
radius=2, are roughly equivalent to ECFP4 and FCFP4.</p>
<p>The user can also provide their own atom invariants using the optional
invariants argument to
<code class="docutils literal"><span class="pre">rdkit.Chem.rdMolDescriptors.GetMorganFingerprint</span></code>.  Here’s a
simple example that uses a constant for the invariant; the resulting
fingerprints compare the topology of molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;Cc1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;Cc1ncncn1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">invariants</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m1</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp2</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">invariants</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m2</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span><span class="o">==</span><span class="n">fp2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note that bond order is by default still considered:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m3</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC1CCCCC1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp3</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">invariants</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m3</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span><span class="o">==</span><span class="n">fp3</span>
<span class="go">False</span>
</pre></div>
</div>
<p>But this can also be turned off:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">invariants</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m1</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">(),</span>
<span class="gp">... </span><span class="n">useBondTypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp3</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">invariants</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m3</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">(),</span>
<span class="gp">... </span><span class="n">useBondTypes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp1</span><span class="o">==</span><span class="n">fp3</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="section" id="explaining-bits-from-morgan-fingerprints">
<h4>Explaining bits from Morgan Fingerprints<a class="headerlink" href="#explaining-bits-from-morgan-fingerprints" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Information is available about the atoms that contribute to particular
bits in the Morgan fingerprint via the bitInfo argument.  The
dictionary provided is populated with one entry per bit set in the
fingerprint, the keys are the bit ids, the values are lists of (atom
index, radius) tuples.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1cccnc1C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">info</span><span class="o">=</span><span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">bitInfo</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">GetNonzeroElements</span><span class="p">())</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">info</span><span class="p">[</span><span class="mi">98513984</span><span class="p">]</span>
<span class="go">((1, 1), (2, 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">info</span><span class="p">[</span><span class="mi">4048591891</span><span class="p">]</span>
<span class="go">((5, 2),)</span>
</pre></div>
</div>
<p>Interpreting the above: bit 98513984 is set twice: once by atom 1 and
once by atom 2, each at radius 1. Bit 4048591891 is set once by atom 5
at radius 2.</p>
<p>Focusing on bit 4048591891, we can extract the submolecule consisting
of all atoms within a radius of 2 of atom 5:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">FindAtomEnvironmentOfRadiusN</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amap</span><span class="o">=</span><span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">submol</span><span class="o">=</span><span class="n">Chem</span><span class="o">.</span><span class="n">PathToSubmol</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">env</span><span class="p">,</span><span class="n">atomMap</span><span class="o">=</span><span class="n">amap</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">submol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amap</span>
<span class="go">{0: 3, 1: 5, 3: 4, 4: 0, 5: 1, 6: 2}</span>
</pre></div>
</div>
<p>And then “explain” the bit by generating SMILES for that submolecule:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">submol</span><span class="p">)</span>
<span class="go">&#39;ccc(C)nc&#39;</span>
</pre></div>
</div>
<p>This is more useful when the SMILES is rooted at the central atom:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">submol</span><span class="p">,</span><span class="n">rootedAtAtom</span><span class="o">=</span><span class="n">amap</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">canonical</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;c(nc)(C)cc&#39;</span>
</pre></div>
</div>
<p>An alternate (and faster, particularly for large numbers of molecules)
approach to do the same thing, using the function <a class="reference external" href="api/rdkit.Chem-module.html#MolFragmentToSmiles">MolFragmentToSmiles</a> :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">bidx</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">atoms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="n">bidx</span><span class="p">)</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">())</span>
<span class="gp">... </span>    <span class="n">atoms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="n">bidx</span><span class="p">)</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">())</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFragmentToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">atomsToUse</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span><span class="n">bondsToUse</span><span class="o">=</span><span class="n">env</span><span class="p">,</span><span class="n">rootedAtAtom</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;c(C)(cc)nc&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="picking-diverse-molecules-using-fingerprints">
<h3>Picking Diverse Molecules Using Fingerprints<a class="headerlink" href="#picking-diverse-molecules-using-fingerprints" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>A common task is to pick a small subset of diverse molecules from a
larger set.  The RDKit provides a number of approaches for doing this
in the <a class="reference external" href="api/rdkit.SimDivFilters-module.html">rdkit.SimDivFilters</a> module.  The most efficient of these uses the
MaxMin algorithm. <a class="footnote-reference" href="#ashton" id="id13">[6]</a> Here’s an example:</p>
<p>Start by reading in a set of molecules and generating Morgan fingerprints:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.rdMolDescriptors</span> <span class="k">import</span> <span class="n">GetMorganFingerprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">DataStructs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.SimDivFilters.rdSimDivPickers</span> <span class="k">import</span> <span class="n">MaxMinPicker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/actives_5ht3.sdf&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">ms</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span> <span class="n">ms</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fps</span> <span class="o">=</span> <span class="p">[</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nfps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
</pre></div>
</div>
<p>The algorithm requires a function to calculate distances between
objects, we’ll do that using DiceSimilarity:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">distij</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">):</span>
<span class="gp">... </span>  <span class="k">return</span> <span class="mi">1</span><span class="o">-</span><span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">fps</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>Now create a picker and grab a set of 10 diverse molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">picker</span> <span class="o">=</span> <span class="n">MaxMinPicker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickIndices</span> <span class="o">=</span> <span class="n">picker</span><span class="o">.</span><span class="n">LazyPick</span><span class="p">(</span><span class="n">distij</span><span class="p">,</span><span class="n">nfps</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">seed</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">pickIndices</span><span class="p">)</span>
<span class="go">[93, 109, 154, 6, 95, 135, 151, 61, 137, 139]</span>
</pre></div>
</div>
<p>Note that the picker just returns indices of the fingerprints; we can
get the molecules themselves as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">picks</span> <span class="o">=</span> <span class="p">[</span><span class="n">ms</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pickIndices</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="generating-similarity-maps-using-fingerprints">
<h3>Generating Similarity Maps Using Fingerprints<a class="headerlink" href="#generating-similarity-maps-using-fingerprints" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Similarity maps are a way to visualize the atomic contributions to
the similarity between a molecule and a reference molecule. The
methodology is described in Ref. <a class="footnote-reference" href="#riniker" id="id14">[17]</a> .
They are in the <a class="reference external" href="api/rdkit.Chem.Draw.SimilarityMaps-module.html">rdkit.Chem.Draw.SimilarityMaps</a> module :</p>
<p>Start by creating two molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;COc1cccc2cc(C(=O)NCCCCN3CCN(c4cccc5nccnc54)CC3)oc21&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">refmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CCCN(CCCCN1CCN(c2ccccc2OC)CC1)Cc1ccc2ccccc2c1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The SimilarityMaps module supports three kind of fingerprints:
atom pairs, topological torsions and Morgan fingerprints.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">Draw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.Draw</span> <span class="k">import</span> <span class="n">SimilarityMaps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetAPFingerprint</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fpType</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetTTFingerprint</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fpType</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fpType</span><span class="o">=</span><span class="s1">&#39;bv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The types of atom pairs and torsions are normal (default), hashed and bit vector (bv).
The types of the Morgan fingerprint are bit vector (bv, default) and count vector (count).</p>
<p>The function generating a similarity map for two fingerprints requires the
specification of the fingerprint function and optionally the similarity metric.
The default for the latter is the Dice similarity. Using all the default arguments
of the Morgan fingerprint function, the similarity map can be generated like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">maxweight</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetSimilarityMapForFingerprint</span><span class="p">(</span><span class="n">refmol</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">)</span>
</pre></div>
</div>
<p>Producing this image:</p>
<img alt="_images/similarity_map_fp1.png" src="_images/similarity_map_fp1.png" />
<p>For a different type of Morgan (e.g. count) and radius = 1 instead of 2, as well as a different
similarity metric (e.g. Tanimoto), the call becomes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">DataStructs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">maxweight</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetSimilarityMapForFingerprint</span><span class="p">(</span><span class="n">refmol</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">,</span><span class="n">idx</span><span class="p">:</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">atomId</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fpType</span><span class="o">=</span><span class="s1">&#39;count&#39;</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="n">DataStructs</span><span class="o">.</span><span class="n">TanimotoSimilarity</span><span class="p">)</span>
</pre></div>
</div>
<p>Producing this image:</p>
<img alt="_images/similarity_map_fp2.png" src="_images/similarity_map_fp2.png" />
<p>The convenience function GetSimilarityMapForFingerprint involves the normalisation
of the atomic weights such that the maximum absolute weight is 1. Therefore, the
function outputs the maximum weight that was found when creating the map.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">maxweight</span><span class="p">)</span>
<span class="go">0.05747...</span>
</pre></div>
</div>
<p>If one does not want the normalisation step, the map can be created like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetAtomicWeightsForFingerprint</span><span class="p">(</span><span class="n">refmol</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">])</span>
<span class="go">[&#39;0.05 &#39;, ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetSimilarityMapFromWeights</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>Producing this image:</p>
<img alt="_images/similarity_map_fp3.png" src="_images/similarity_map_fp3.png" />
</div>
</div>
<div class="section" id="descriptor-calculation">
<h2>Descriptor Calculation<a class="headerlink" href="#descriptor-calculation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A variety of descriptors are available within the RDKit.
The complete list is provided in <a class="reference internal" href="#list-of-available-descriptors">List of Available Descriptors</a>.</p>
<p>Most of the descriptors are straightforward to use from Python via the
centralized <a class="reference external" href="api/rdkit.Chem.Descriptors-module.html">rdkit.Chem.Descriptors</a> module :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">Descriptors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1C(=O)O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Descriptors</span><span class="o">.</span><span class="n">TPSA</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">37.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Descriptors</span><span class="o">.</span><span class="n">MolLogP</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">1.3848</span>
</pre></div>
</div>
<p>Partial charges are handled a bit differently:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1C(=O)O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">ComputeGasteigerCharges</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;_GasteigerCharge&#39;</span><span class="p">))</span>
<span class="go">-0.047...</span>
</pre></div>
</div>
<div class="section" id="visualization-of-descriptors">
<h3>Visualization of Descriptors<a class="headerlink" href="#visualization-of-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Similarity maps can be used to visualize descriptors that can be divided into
atomic contributions.</p>
<p>The Gasteiger partial charges can be visualized as (using a different color scheme):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.Draw</span> <span class="k">import</span> <span class="n">SimilarityMaps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;COc1cccc2cc(C(=O)NCCCCN3CCN(c4cccc5nccnc54)CC3)oc21&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">ComputeGasteigerCharges</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contribs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;_GasteigerCharge&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetSimilarityMapFromWeights</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">contribs</span><span class="p">,</span> <span class="n">colorMap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">contourLines</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Producing this image:</p>
<img alt="_images/similarity_map_charges.png" src="_images/similarity_map_charges.png" />
<p>Or for the Crippen contributions to logP:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">rdMolDescriptors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contribs</span> <span class="o">=</span> <span class="n">rdMolDescriptors</span><span class="o">.</span><span class="n">_CalcCrippenContribs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">SimilarityMaps</span><span class="o">.</span><span class="n">GetSimilarityMapFromWeights</span><span class="p">(</span><span class="n">mol</span><span class="p">,[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">contribs</span><span class="p">],</span> <span class="n">colorMap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">contourLines</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Producing this image:</p>
<img alt="_images/similarity_map_crippen.png" src="_images/similarity_map_crippen.png" />
</div>
</div>
<div class="section" id="chemical-reactions">
<h2>Chemical Reactions<a class="headerlink" href="#chemical-reactions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The RDKit also supports applying chemical reactions to sets of
molecules.  One way of constructing chemical reactions is to use a
SMARTS-based language similar to Daylight’s Reaction SMILES
<a class="footnote-reference" href="#rxnsmarts" id="id15">[11]</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReactionFromSmarts</span><span class="p">(</span><span class="s1">&#39;[C:1](=[O:2])-[OD1].[N!H0:3]&gt;&gt;[C:1](=[O:2])[N:3]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span>
<span class="go">&lt;rdkit.Chem.rdChemReactions.ChemicalReaction object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span><span class="o">.</span><span class="n">GetNumProductTemplates</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">rxn</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(=O)O&#39;</span><span class="p">),</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;NC&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span> <span class="c1"># one entry for each possible set of products</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># each entry contains one molecule for each product</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;CNC(C)=O&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">rxn</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C(COC(=O)O)C(=O)O&#39;</span><span class="p">),</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;NC&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;CNC(=O)OCCC(=O)O&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;CNC(=O)CCOC(=O)O&#39;</span>
</pre></div>
</div>
<p>Reactions can also be built from MDL rxn files:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReactionFromRxnFile</span><span class="p">(</span><span class="s1">&#39;data/AmideBond.rxn&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span><span class="o">.</span><span class="n">GetNumReactantTemplates</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span><span class="o">.</span><span class="n">GetNumProductTemplates</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">rxn</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(=O)O&#39;</span><span class="p">),</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;NC&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;CNC(C)=O&#39;</span>
</pre></div>
</div>
<p>It is, of course, possible to do reactions more complex than amide
bond formation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReactionFromSmarts</span><span class="p">(</span><span class="s1">&#39;[C:1]=[C:2].[C:3]=[*:4][*:5]=[C:6]&gt;&gt;[C:1]1[C:2][C:3][*:4]=[*:5][C:6]1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">rxn</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OC=C&#39;</span><span class="p">),</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C=CC(N)=C&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;NC1=CCCC(O)C1&#39;</span>
</pre></div>
</div>
<p>Note in this case that there are multiple mappings of the reactants
onto the templates, so we have multiple product sets:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>You can use canonical smiles and a python dictionary to get the unique products:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">uniqps</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">smi</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>  <span class="n">uniqps</span><span class="p">[</span><span class="n">smi</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">uniqps</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;NC1=CCC(O)CC1&#39;, &#39;NC1=CCCC(O)C1&#39;]</span>
</pre></div>
</div>
<p>Note that the molecules that are produced by the chemical reaction
processing code are not sanitized, as this artificial reaction
demonstrates:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReactionFromSmarts</span><span class="p">(</span><span class="s1">&#39;[C:1]=[C:2][C:3]=[C:4].[C:5]=[C:6]&gt;&gt;[C:1]1=[C:2][C:3]=[C:4][C:5]=[C:6]1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">rxn</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C=CC=C&#39;</span><span class="p">),</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C=C&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;C1=CC=CC=C1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p0</span> <span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
<span class="go">rdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_NONE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
<span class="go">&#39;c1ccccc1&#39;</span>
</pre></div>
</div>
<div class="section" id="advanced-reaction-functionality">
<h3>Advanced Reaction Functionality<a class="headerlink" href="#advanced-reaction-functionality" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="protecting-atoms">
<h4>Protecting Atoms<a class="headerlink" href="#protecting-atoms" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Sometimes, particularly when working with rxn files, it is difficult
to express a reaction exactly enough to not end up with extraneous
products. The RDKit provides a method of 「protecting」 atoms to
disallow them from taking part in reactions.</p>
<p>This can be demonstrated re-using the amide-bond formation reaction used
above. The query for amines isn’t specific enough, so it matches any
nitrogen that has at least one H attached. So if we apply the reaction
to a molecule that already has an amide bond, the amide N is also
treated as a reaction site:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rxn</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">ReactionFromRxnFile</span><span class="p">(</span><span class="s1">&#39;data/AmideBond.rxn&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">acid</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(=O)O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(=O)NCCN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">rxn</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">acid</span><span class="p">,</span><span class="n">base</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;CC(=O)N(CCN)C(C)=O&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;CC(=O)NCCNC(C)=O&#39;</span>
</pre></div>
</div>
<p>The first product corresponds to the reaction at the amide N.</p>
<p>We can prevent this from happening by protecting all amide Ns. Here we
do it with a substructure query that matches amides and thioamides and
then set the 「_protected」 property on matching atoms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">amidep</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;[N;$(NC=[O,S])]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">amidep</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">base</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s1">&#39;_protected&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now the reaction only generates a single product:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">rxn</span><span class="o">.</span><span class="n">RunReactants</span><span class="p">((</span><span class="n">acid</span><span class="p">,</span><span class="n">base</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;CC(=O)NCCNC(C)=O&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="recap-implementation">
<h3>Recap Implementation<a class="headerlink" href="#recap-implementation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Associated with the chemical reaction functionality is an
implementation of the Recap algorithm. <a class="footnote-reference" href="#lewell" id="id16">[8]</a> Recap uses a set of
chemical transformations mimicking common reactions carried out in the
lab in order to decompose a molecule into a series of reasonable
fragments.</p>
<p>The RDKit <a class="reference external" href="api/rdkit.Chem.Recap-module.html">rdkit.Chem.Recap</a> implementation keeps track of the hierarchy of
transformations that were applied:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">Recap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1OCCOC(=O)CC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hierarch</span> <span class="o">=</span> <span class="n">Recap</span><span class="o">.</span><span class="n">RecapDecompose</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">hierarch</span><span class="p">)</span>
<span class="go">&lt;class &#39;rdkit.Chem.Recap.RecapHierarchyNode&#39;&gt;</span>
</pre></div>
</div>
<p>The hierarchy is rooted at the original molecule:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hierarch</span><span class="o">.</span><span class="n">smiles</span>
<span class="go">&#39;CCC(=O)OCCOc1ccccc1&#39;</span>
</pre></div>
</div>
<p>and each node tracks its children using a dictionary keyed by SMILES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ks</span><span class="o">=</span><span class="n">hierarch</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>
<span class="go">[&#39;[*]C(=O)CC&#39;, &#39;[*]CCOC(=O)CC&#39;, &#39;[*]CCOc1ccccc1&#39;, &#39;[*]OCCOc1ccccc1&#39;, &#39;[*]c1ccccc1&#39;]</span>
</pre></div>
</div>
<p>The nodes at the bottom of the hierarchy (the leaf nodes) are easily
accessible, also as a dictionary keyed by SMILES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ks</span><span class="o">=</span><span class="n">hierarch</span><span class="o">.</span><span class="n">GetLeaves</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ks</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ks</span>
<span class="go">[&#39;[*]C(=O)CC&#39;, &#39;[*]CCO[*]&#39;, &#39;[*]CCOc1ccccc1&#39;, &#39;[*]c1ccccc1&#39;]</span>
</pre></div>
</div>
<p>Notice that dummy atoms are used to mark points where the molecule was fragmented.</p>
<p>The nodes themselves have associated molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">leaf</span> <span class="o">=</span> <span class="n">hierarch</span><span class="o">.</span><span class="n">GetLeaves</span><span class="p">()[</span><span class="n">ks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
<span class="go">&#39;[*]C(=O)CC&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="brics-implementation">
<h3>BRICS Implementation<a class="headerlink" href="#brics-implementation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The RDKit also provides an implementation of the BRICS
algorithm. <a class="footnote-reference" href="#degen" id="id17">[9]</a> BRICS provides another
method for fragmenting molecules along synthetically accessible bonds:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">BRICS</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdk2mols</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/cdk2.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">cdk2mols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">BRICS</span><span class="o">.</span><span class="n">BRICSDecompose</span><span class="p">(</span><span class="n">m1</span><span class="p">))</span>
<span class="go">[&#39;[14*]c1nc(N)nc2[nH]cnc12&#39;, &#39;[3*]O[3*]&#39;, &#39;[4*]CC(=O)C(C)C&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">cdk2mols</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">BRICS</span><span class="o">.</span><span class="n">BRICSDecompose</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span>
<span class="go">[&#39;[1*]C(=O)NN(C)C&#39;, &#39;[14*]c1[nH]nc2c1C(=O)c1c([16*])cccc1-2&#39;, &#39;[16*]c1ccc([16*])cc1&#39;, &#39;[3*]OC&#39;, &#39;[5*]N[5*]&#39;]</span>
</pre></div>
</div>
<p>Notice that RDKit BRICS implementation returns the unique fragments
generated from a molecule and that the dummy atoms are tagged to
indicate which type of reaction applies.</p>
<p>It’s quite easy to generate the list of all fragments for a
group of molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">allfrags</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">cdk2mols</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">pieces</span> <span class="o">=</span> <span class="n">BRICS</span><span class="o">.</span><span class="n">BRICSDecompose</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">allfrags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pieces</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">allfrags</span><span class="p">)</span>
<span class="go">90</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">allfrags</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[&#39;NS(=O)(=O)c1ccc(N/N=C2\\C(=O)Nc3ccc(Br)cc32)cc1&#39;, &#39;[1*]C(=O)C(C)C&#39;, &#39;[1*]C(=O)NN(C)C&#39;, &#39;[1*]C(=O)NN1CC[NH+](C)CC1&#39;, &#39;[1*]C(C)=O&#39;]</span>
</pre></div>
</div>
<p>The BRICS module also provides an option to apply the BRICS rules to a
set of fragments to create new molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">127</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fragms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">allfrags</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="n">BRICS</span><span class="o">.</span><span class="n">BRICSBuild</span><span class="p">(</span><span class="n">fragms</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is a generator object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span>
<span class="go">&lt;generator object BRICSBuild at 0x...&gt;</span>
</pre></div>
</div>
<p>That returns molecules on request:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prods</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;rdkit.Chem.rdchem.Mol object at 0x...&gt;</span>
</pre></div>
</div>
<p>The molecules have not been sanitized, so it’s a good idea to at least update the valences before continuing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">prod</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;COCCO&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">prods</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;O=C1Nc2ccc3ncsc3c2/C1=C/NCCO&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">prods</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;O=C1Nc2ccccc2/C1=C/NCCO&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="other-fragmentation-approaches">
<h3>Other fragmentation approaches<a class="headerlink" href="#other-fragmentation-approaches" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In addition to the methods described above, the RDKit provide a very
flexible generic function for fragmenting molecules along
user-specified bonds.</p>
<p>Here’s a quick demonstration of using that to break all bonds between
atoms in rings and atoms not in rings. We start by finding all the
atom pairs:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC1CC(O)C1CCC1CC1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bis</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;[!R][R]&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bis</span>
<span class="go">((0, 1), (4, 3), (6, 5), (7, 8))</span>
</pre></div>
</div>
<p>then we get the corresponding bond indices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">bis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span>
<span class="go">[0, 3, 5, 7]</span>
</pre></div>
</div>
<p>then we use those bond indices as input to the fragmentation function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nm</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">FragmentOnBonds</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">bs</span><span class="p">)</span>
</pre></div>
</div>
<p>the output is a molecule that has dummy atoms marking the places where
bonds were broken:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;[*]C1CC([4*])C1[6*].[1*]C.[3*]O.[5*]CC[8*].[7*]C1CC1&#39;</span>
</pre></div>
</div>
<p>By default the attachment points are labelled (using isotopes) with
the index of the atom that was removed. We can also provide our own set of
atom labels in the form of pairs of unsigned integers. The first value
in each pair is used as the label for the dummy that replaces the
bond’s begin atom, the second value in each pair is for the dummy that
replaces the bond’s end atom. Here’s an example, repeating the
analysis above and marking the positions where the non-ring atoms were
with the label 10 and marking the positions where the ring atoms were
with label 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bis</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s1">&#39;[!R][R]&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span><span class="o">=</span><span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">bis</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">b</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">bi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>   <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span><span class="o">==</span><span class="n">bi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="gp">... </span>       <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">... </span>   <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>       <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">... </span>   <span class="n">bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nm</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">FragmentOnBonds</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">bs</span><span class="p">,</span><span class="n">dummyLabels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;[1*]C.[1*]CC[1*].[1*]O.[10*]C1CC([10*])C1[10*].[10*]C1CC1&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="chemical-features-and-pharmacophores">
<h2>Chemical Features and Pharmacophores<a class="headerlink" href="#chemical-features-and-pharmacophores" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="chemical-features">
<h3>Chemical Features<a class="headerlink" href="#chemical-features" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Chemical features in the RDKit are defined using a SMARTS-based feature definition language (described in detail in the RDKit book).
To identify chemical features in molecules, you first must build a feature factory:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">ChemicalFeatures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">RDConfig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fdefName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">RDConfig</span><span class="o">.</span><span class="n">RDDataDir</span><span class="p">,</span><span class="s1">&#39;BaseFeatures.fdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span> <span class="o">=</span> <span class="n">ChemicalFeatures</span><span class="o">.</span><span class="n">BuildFeatureFactory</span><span class="p">(</span><span class="n">fdefName</span><span class="p">)</span>
</pre></div>
</div>
<p>and then use the factory to search for features:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OCc1ccccc1CN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feats</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">GetFeaturesForMol</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">feats</span><span class="p">)</span>
<span class="go">8</span>
</pre></div>
</div>
<p>The individual features carry information about their family (e.g. donor, acceptor, etc.), type (a more detailed description), and the atom(s) that is/are associated with the feature:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">feats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetFamily</span><span class="p">()</span>
<span class="go">&#39;Donor&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetType</span><span class="p">()</span>
<span class="go">&#39;SingleAtomDonor&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetAtomIds</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feats</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">GetFamily</span><span class="p">()</span>
<span class="go">&#39;Aromatic&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feats</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">GetAtomIds</span><span class="p">()</span>
<span class="go">(2, 3, 4, 5, 6, 7)</span>
</pre></div>
</div>
<p>If the molecule has coordinates, then the features will also have reasonable locations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AllChem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AllChem</span><span class="o">.</span><span class="n">Compute2DCoords</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetPos</span><span class="p">()</span>
<span class="go">&lt;rdkit.Geometry.rdGeometry.Point3D object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">feats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetPos</span><span class="p">())</span>
<span class="go">[2.07..., -2.335..., 0.0]</span>
</pre></div>
</div>
</div>
<div class="section" id="d-pharmacophore-fingerprints">
<h3>2D Pharmacophore Fingerprints<a class="headerlink" href="#d-pharmacophore-fingerprints" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Combining a set of chemical features with the 2D (topological)
distances between them gives a 2D pharmacophore.  When the distances
are binned, unique integer ids can be assigned to each of these
pharmacophores and they can be stored in a fingerprint.  Details of
the encoding are in the <a class="reference internal" href="RDKit_Book.html"><span class="doc">The RDKit Book</span></a>.</p>
<p>Generating pharmacophore fingerprints requires chemical features
generated via the usual RDKit feature-typing mechanism:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">ChemicalFeatures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fdefName</span> <span class="o">=</span> <span class="s1">&#39;data/MinimalFeatures.fdef&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">featFactory</span> <span class="o">=</span> <span class="n">ChemicalFeatures</span><span class="o">.</span><span class="n">BuildFeatureFactory</span><span class="p">(</span><span class="n">fdefName</span><span class="p">)</span>
</pre></div>
</div>
<p>The fingerprints themselves are calculated using a signature
(fingerprint) factory, which keeps track of all the parameters
required to generate the pharmacophore:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.Pharm2D.SigFactory</span> <span class="k">import</span> <span class="n">SigFactory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span> <span class="o">=</span> <span class="n">SigFactory</span><span class="p">(</span><span class="n">featFactory</span><span class="p">,</span><span class="n">minPointCount</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">maxPointCount</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">SetBins</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">GetSigSize</span><span class="p">()</span>
<span class="go">885</span>
</pre></div>
</div>
<p>The signature factory is now ready to be used to generate
fingerprints, a task which is done using the
<a class="reference external" href="api/rdkit.Chem.Pharm2D.Generate-module.html">rdkit.Chem.Pharm2D.Generate</a> module:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.Pharm2D</span> <span class="k">import</span> <span class="n">Generate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OCC(=O)CCCN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">Generate</span><span class="o">.</span><span class="n">Gen2DFingerprint</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="n">sigFactory</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span>
<span class="go">&lt;rdkit.DataStructs.cDataStructs.SparseBitVect object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">885</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">GetNumOnBits</span><span class="p">()</span>
<span class="go">57</span>
</pre></div>
</div>
<p>Details about the bits themselves, including the features that are
involved and the binned distance matrix between the features, can be
obtained from the signature factory:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">GetOnBits</span><span class="p">())[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[1, 2, 6, 7, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">GetBitDescription</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Acceptor Acceptor |0 1|1 0|&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">GetBitDescription</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;Acceptor Acceptor |0 2|2 0|&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">GetBitDescription</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;Acceptor Donor |0 2|2 0|&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">GetOnBits</span><span class="p">())[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>
<span class="go">[704, 706, 707, 708, 714]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">GetBitDescription</span><span class="p">(</span><span class="mi">707</span><span class="p">)</span>
<span class="go">&#39;Donor Donor PosIonizable |0 1 2|1 0 1|2 1 0|&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">GetBitDescription</span><span class="p">(</span><span class="mi">714</span><span class="p">)</span>
<span class="go">&#39;Donor Donor PosIonizable |0 2 2|2 0 0|2 0 0|&#39;</span>
</pre></div>
</div>
<p>For the sake of convenience (to save you from having to edit the fdef
file every time) it is possible to disable particular feature types
within the SigFactory:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">skipFeats</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;PosIonizable&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigFactory</span><span class="o">.</span><span class="n">GetSigSize</span><span class="p">()</span>
<span class="go">510</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp2</span> <span class="o">=</span> <span class="n">Generate</span><span class="o">.</span><span class="n">Gen2DFingerprint</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="n">sigFactory</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp2</span><span class="o">.</span><span class="n">GetNumOnBits</span><span class="p">()</span>
<span class="go">36</span>
</pre></div>
</div>
<p>Another possible set of feature definitions for 2D pharmacophore
fingerprints in the RDKit are those published by Gobbi and
Poppinger. <a class="footnote-reference" href="#gobbi" id="id18">[10]</a> The module
<a class="reference external" href="api/rdkit.Chem.Pharm2D.Gobbi_Pharm2D-module.html">rdkit.Chem.Pharm2D.Gobbi_Pharm2D</a> has a pre-configured signature
factory for these fingerprint types.  Here’s an example of using it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem.Pharm2D</span> <span class="k">import</span> <span class="n">Gobbi_Pharm2D</span><span class="p">,</span><span class="n">Generate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OCC=CC(=O)O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">Generate</span><span class="o">.</span><span class="n">Gen2DFingerprint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">Gobbi_Pharm2D</span><span class="o">.</span><span class="n">factory</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span>
<span class="go">&lt;rdkit.DataStructs.cDataStructs.SparseBitVect object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">GetNumOnBits</span><span class="p">()</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">GetOnBits</span><span class="p">())</span>
<span class="go">[23, 30, 150, 154, 157, 185, 28878, 30184]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Gobbi_Pharm2D</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">GetBitDescription</span><span class="p">(</span><span class="mi">157</span><span class="p">)</span>
<span class="go">&#39;HA HD |0 3|3 0|&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Gobbi_Pharm2D</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">GetBitDescription</span><span class="p">(</span><span class="mi">30184</span><span class="p">)</span>
<span class="go">&#39;HA HD HD |0 3 0|3 0 3|0 3 0|&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="molecular-fragments">
<h2>Molecular Fragments<a class="headerlink" href="#molecular-fragments" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The RDKit contains a collection of tools for fragmenting molecules and
working with those fragments.  Fragments are defined to be made up of
a set of connected atoms that may have associated functional groups.
This is more easily demonstrated than explained:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fName</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">RDConfig</span><span class="o">.</span><span class="n">RDDataDir</span><span class="p">,</span><span class="s1">&#39;FunctionalGroups.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">FragmentCatalog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fparams</span> <span class="o">=</span> <span class="n">FragmentCatalog</span><span class="o">.</span><span class="n">FragCatParams</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="n">fName</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fparams</span><span class="o">.</span><span class="n">GetNumFuncGroups</span><span class="p">()</span>
<span class="go">39</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">=</span><span class="n">FragmentCatalog</span><span class="o">.</span><span class="n">FragCatalog</span><span class="p">(</span><span class="n">fparams</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcgen</span><span class="o">=</span><span class="n">FragmentCatalog</span><span class="o">.</span><span class="n">FragCatGenerator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OCC=CC(=O)O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcgen</span><span class="o">.</span><span class="n">AddFragsFromMol</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">fcat</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;C&lt;-O&gt;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;C=C&lt;-C(=O)O&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;C&lt;-C(=O)O&gt;=CC&lt;-O&gt;&#39;</span>
</pre></div>
</div>
<p>The fragments are stored as entries in a
<code class="docutils literal"><span class="pre">rdkit.Chem.rdfragcatalog.FragCatalog</span></code>.  Notice that the
entry descriptions include pieces in angular brackets (e.g. between
『&lt;』 and 『&gt;』).  These describe the functional groups attached to the
fragment.  For example, in the above example, the catalog entry 0
corresponds to an ethyl fragment with an alcohol attached to one of
the carbons and entry 1 is an ethylene with a carboxylic acid on one
carbon.  Detailed information about the functional groups can be
obtained by asking the fragment for the ids of the functional groups
it contains and then looking those ids up in the
<code class="docutils literal"><span class="pre">rdkit.Chem.rdfragcatalog.FragCatParams</span></code>
object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryFuncGroupIds</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[34, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fparams</span><span class="o">.</span><span class="n">GetFuncGroup</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;rdkit.Chem.rdchem.Mol object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">fparams</span><span class="o">.</span><span class="n">GetFuncGroup</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">&#39;*-C(=O)-,:[O&amp;D1]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">fparams</span><span class="o">.</span><span class="n">GetFuncGroup</span><span class="p">(</span><span class="mi">34</span><span class="p">))</span>
<span class="go">&#39;*-[O&amp;D1]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fparams</span><span class="o">.</span><span class="n">GetFuncGroup</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;_Name&#39;</span><span class="p">)</span>
<span class="go">&#39;-C(=O)O&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fparams</span><span class="o">.</span><span class="n">GetFuncGroup</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;_Name&#39;</span><span class="p">)</span>
<span class="go">&#39;-O&#39;</span>
</pre></div>
</div>
<p>The catalog is hierarchical: smaller fragments are combined to form
larger ones.  From a small fragment, one can find the larger fragments
to which it contributes using the
<code class="docutils literal"><span class="pre">rdkit.Chem.rdfragcatalog.FragCatalog.GetEntryDownIds</span></code>
method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">=</span><span class="n">FragmentCatalog</span><span class="o">.</span><span class="n">FragCatalog</span><span class="p">(</span><span class="n">fparams</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;OCC(NC1CC1)CCC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcgen</span><span class="o">.</span><span class="n">AddFragsFromMol</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">fcat</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;C&lt;-O&gt;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;CN&lt;-cPropyl&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDownIds</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;C&lt;-O&gt;CC&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;C&lt;-O&gt;CN&lt;-cPropyl&gt;&#39;</span>
</pre></div>
</div>
<p>The fragments from multiple molecules can be added to a catalog:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SmilesMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/bzr.smi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">suppl</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">=</span><span class="n">FragmentCatalog</span><span class="o">.</span><span class="n">FragCatalog</span><span class="p">(</span><span class="n">fparams</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">:</span> <span class="n">nAdded</span><span class="o">=</span><span class="n">fcgen</span><span class="o">.</span><span class="n">AddFragsFromMol</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">fcat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetNumEntries</span><span class="p">()</span>
<span class="go">1169</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;Cc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">&#39;cc-nc(C)n&#39;</span>
</pre></div>
</div>
<p>The fragments in a catalog are unique, so adding a molecule a second
time doesn’t add any new entries:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fcgen</span><span class="o">.</span><span class="n">AddFragsFromMol</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fcat</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetNumEntries</span><span class="p">()</span>
<span class="go">1169</span>
</pre></div>
</div>
<p>Once a <code class="docutils literal"><span class="pre">rdkit.Chem.rdfragcatalog.FragCatalog</span></code> has been
generated, it can be used to fingerprint molecules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpgen</span> <span class="o">=</span> <span class="n">FragmentCatalog</span><span class="o">.</span><span class="n">FragFPGenerator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">fpgen</span><span class="o">.</span><span class="n">GetFPForMol</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="n">fcat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span>
<span class="go">&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">GetNumOnBits</span><span class="p">()</span>
<span class="go">189</span>
</pre></div>
</div>
<p>The rest of the machinery associated with fingerprints can now be
applied to these fragment fingerprints.  For example, it’s easy to
find the fragments that two molecules have in common by taking the
intersection of their fingerprints:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp2</span> <span class="o">=</span> <span class="n">fpgen</span><span class="o">.</span><span class="n">GetFPForMol</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="n">fcat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">andfp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">&amp;</span><span class="n">fp2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">andfp</span><span class="o">.</span><span class="n">GetOnBits</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="n">obl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">&#39;ccc(cc)NC&lt;=O&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="n">obl</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span>
<span class="go">&#39;c&lt;-X&gt;ccc(N)cc&#39;</span>
</pre></div>
</div>
<p>or we can find the fragments that distinguish one molecule from
another:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">combinedFp</span><span class="o">=</span><span class="n">fp</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fp</span><span class="o">^</span><span class="n">fp2</span><span class="p">)</span> <span class="c1"># can be more efficent than fp&amp;(!fp2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinedFp</span><span class="o">.</span><span class="n">GetOnBits</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fcat</span><span class="o">.</span><span class="n">GetEntryDescription</span><span class="p">(</span><span class="n">obl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">&#39;cccc(N)cc&#39;</span>
</pre></div>
</div>
<p>Or we can use the bit ranking functionality from the
<code class="docutils literal"><span class="pre">rdkit.ML.InfoTheory.rdInfoTheory.InfoBitRanker</span></code> class to identify fragments
that distinguish actives from inactives:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suppl</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDMolSupplier</span><span class="p">(</span><span class="s1">&#39;data/bzr.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sdms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">suppl</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fps</span> <span class="o">=</span> <span class="p">[</span><span class="n">fpgen</span><span class="o">.</span><span class="n">GetFPForMol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">fcat</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sdms</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.ML.InfoTheory</span> <span class="k">import</span> <span class="n">InfoBitRanker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ranker</span> <span class="o">=</span> <span class="n">InfoBitRanker</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">acts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;ACTIVITY&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sdms</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">fp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fps</span><span class="p">):</span>
<span class="gp">... </span>  <span class="n">act</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">acts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">... </span>  <span class="n">ranker</span><span class="o">.</span><span class="n">AccumulateVotes</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="n">act</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top5</span> <span class="o">=</span> <span class="n">ranker</span><span class="o">.</span><span class="n">GetTopN</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">gain</span><span class="p">,</span><span class="n">n0</span><span class="p">,</span><span class="n">n1</span> <span class="ow">in</span> <span class="n">top5</span><span class="p">:</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">id</span><span class="p">),</span><span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">gain</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">n0</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">n1</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">702 0.081 20 17</span>
<span class="go">328 0.073 23 25</span>
<span class="go">341 0.073 30 43</span>
<span class="go">173 0.073 30 43</span>
<span class="go">1034 0.069 5 53</span>
</pre></div>
</div>
<p>The columns above are: bitId, infoGain, nInactive, nActive. Note that
this approach isn’t particularly effective for this artificial
example.</p>
</div>
<div class="section" id="non-chemical-functionality">
<h2>Non-Chemical Functionality<a class="headerlink" href="#non-chemical-functionality" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="bit-vectors">
<h3>Bit vectors<a class="headerlink" href="#bit-vectors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Bit vectors are containers for efficiently storing a set number of binary values, e.g. for fingerprints.
The RDKit includes two types of fingerprints differing in how they store the values internally; the two types are easily interconverted but are best used for different purpose:</p>
<ul class="simple">
<li>SparseBitVects store only the list of bits set in the vector; they are well suited for storing very large, very sparsely occupied vectors like pharmacophore fingerprints.
Some operations, such as retrieving the list of on bits, are quite fast.
Others, such as negating the vector, are very, very slow.</li>
<li>ExplicitBitVects keep track of both on and off bits.
They are generally faster than SparseBitVects, but require more memory to store.</li>
</ul>
</div>
<div class="section" id="discrete-value-vectors">
<h3>Discrete value vectors<a class="headerlink" href="#discrete-value-vectors" title="このヘッドラインへのパーマリンク">¶</a></h3>
</div>
<div class="section" id="d-grids">
<h3>3D grids<a class="headerlink" href="#d-grids" title="このヘッドラインへのパーマリンク">¶</a></h3>
</div>
<div class="section" id="points">
<h3>Points<a class="headerlink" href="#points" title="このヘッドラインへのパーマリンク">¶</a></h3>
</div>
</div>
<div class="section" id="getting-help">
<h2>Getting Help<a class="headerlink" href="#getting-help" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>There is a reasonable amount of documentation available within from the RDKit’s docstrings.
These are accessible using Python’s help command:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;Cc1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">)</span>
<span class="go">Help on method GetNumAtoms:</span>

<span class="go">GetNumAtoms(...) method of rdkit.Chem.rdchem.Mol instance</span>
<span class="go">    GetNumAtoms( (Mol)arg1 [, (int)onlyHeavy=-1 [, (bool)onlyExplicit=True]]) -&gt; int :</span>
<span class="go">        Returns the number of atoms in the molecule.</span>

<span class="go">          ARGUMENTS:</span>
<span class="go">            - onlyExplicit: (optional) include only explicit atoms (atoms in the molecular graph)</span>
<span class="go">                            defaults to 1.</span>
<span class="go">          NOTE: the onlyHeavy argument is deprecated</span>


<span class="go">        C++ signature :</span>
<span class="go">            int GetNumAtoms(RDKit::ROMol [,int=-1 [,bool=True]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">(</span><span class="n">onlyExplicit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
<p>When working in an environment that does command completion or tooltips, one can see the available methods quite easily.
Here’s a sample screenshot from within the Jupyter notebook:</p>
<img alt="_images/picture_6.png" src="_images/picture_6.png" />
</div>
<div class="section" id="advanced-topics-warnings">
<h2>Advanced Topics/Warnings<a class="headerlink" href="#advanced-topics-warnings" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="editing-molecules">
<h3>Editing Molecules<a class="headerlink" href="#editing-molecules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Some of the functionality provided allows molecules to be edited “in place”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">SetAtomicNum</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">rdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_NONE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&#39;c1ccncc1&#39;</span>
</pre></div>
</div>
<p>Do not forget the sanitization step, without it one can end up with results that look ok (so long as you don’t think):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;c1ccccc1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">SetAtomicNum</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">&#39;c1ccocc1&#39;</span>
</pre></div>
</div>
<p>but that are, of course, complete nonsense, as sanitization will indicate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;/usr/lib/python2.6/doctest.py&quot;</span>, line <span class="m">1253</span>, in <span class="n">__run</span>
    <span class="n">compileflags</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">test</span><span class="o">.</span><span class="n">globs</span>
  File <span class="nb">&quot;&lt;doctest default[0]&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
    <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gr">ValueError</span>: <span class="n">Sanitization error: Can&#39;t kekulize mol</span>
</pre></div>
</div>
<p>More complex transformations can be carried out using the
<code class="docutils literal"><span class="pre">rdkit.Chem.rdchem.RWMol</span></code> class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC(=O)C=CC=C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span><span class="o">.</span><span class="n">ReplaceAtom</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">Chem</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span><span class="o">.</span><span class="n">RemoveAtom</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mw</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span>
<span class="go">8</span>
</pre></div>
</div>
<p>The RWMol can be used just like an ROMol:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">mw</span><span class="p">)</span>
<span class="go">&#39;O=CC1C=CC=CN=1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">mw</span><span class="p">)</span>
<span class="go">rdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_NONE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">mw</span><span class="p">)</span>
<span class="go">&#39;O=Cc1ccccn1&#39;</span>
</pre></div>
</div>
<p>It is even easier to generate nonsense using the RWMol than it
is with standard molecules.  If you need chemically reasonable
results, be certain to sanitize the results.</p>
</div>
</div>
<div class="section" id="miscellaneous-tips-and-hints">
<h2>Miscellaneous Tips and Hints<a class="headerlink" href="#miscellaneous-tips-and-hints" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="chem-vs-allchem">
<h3>Chem vs AllChem<a class="headerlink" href="#chem-vs-allchem" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The majority of “basic” chemical functionality (e.g. reading/writing
molecules, substructure searching, molecular cleanup, etc.) is in the
<a class="reference external" href="api/rdkit.Chem-module.html">rdkit.Chem</a> module.  More advanced, or less frequently used,
functionality is in <a class="reference external" href="api/rdkit.Chem.AllChem-module.html">rdkit.Chem.AllChem</a>.  The distinction has
been made to speed startup and lower import times; there’s no sense in
loading the 2D-&gt;3D library and force field implementation if one is
only interested in reading and writing a couple of molecules.  If you
find the Chem/AllChem thing annoying or confusing, you can use
python’s “import … as …” syntax to remove the irritation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">AllChem</span> <span class="k">as</span> <span class="n">Chem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CCC&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-sssr-problem">
<h3>The SSSR Problem<a class="headerlink" href="#the-sssr-problem" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>As others have ranted about with more energy and eloquence than I
intend to, the definition of a molecule’s smallest set of smallest
rings is not unique.  In some high symmetry molecules, a “true” SSSR
will give results that are unappealing.  For example, the SSSR for
cubane only contains 5 rings, even though there are
“obviously” 6. This problem can be fixed by implementing a <em>small</em>
(instead of <em>smallest</em>) set of smallest rings algorithm that returns
symmetric results.  This is the approach that we took with the RDKit.</p>
<p>Because it is sometimes useful to be able to count how many SSSR rings
are present in the molecule, there is a
<code class="docutils literal"><span class="pre">rdkit.Chem.rdmolops.GetSSSR</span></code> function, but this only returns the
SSSR count, not the potentially non-unique set of rings.</p>
</div>
</div>
<div class="section" id="list-of-available-descriptors">
<h2>List of Available Descriptors<a class="headerlink" href="#list-of-available-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="49%" />
<col width="8%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Descriptor/Descriptor
Family</td>
<td>Notes</td>
<td>Language</td>
</tr>
<tr class="row-even"><td>Gasteiger/Marsili
Partial Charges</td>
<td><em>Tetrahedron</em>
<strong>36</strong>:3219-28
(1980)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>BalabanJ</td>
<td><em>Chem. Phys. Lett.</em>
<strong>89</strong>:399-404
(1982)</td>
<td>Python</td>
</tr>
<tr class="row-even"><td>BertzCT</td>
<td><em>J. Am. Chem. Soc.</em>
<strong>103</strong>:3599-601
(1981)</td>
<td>Python</td>
</tr>
<tr class="row-odd"><td>Ipc</td>
<td><em>J. Chem. Phys.</em>
<strong>67</strong>:4517-33
(1977)</td>
<td>Python</td>
</tr>
<tr class="row-even"><td>HallKierAlpha</td>
<td><em>Rev. Comput. Chem.</em>
<strong>2</strong>:367-422
(1991)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>Kappa1 - Kappa3</td>
<td><em>Rev. Comput. Chem.</em>
<strong>2</strong>:367-422
(1991)</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Chi0, Chi1</td>
<td><em>Rev. Comput. Chem.</em>
<strong>2</strong>:367-422
(1991)</td>
<td>Python</td>
</tr>
<tr class="row-odd"><td>Chi0n - Chi4n</td>
<td><em>Rev. Comput. Chem.</em>
<strong>2</strong>:367-422
(1991)</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Chi0v - Chi4v</td>
<td><em>Rev. Comput. Chem.</em>
<strong>2</strong>:367-422
(1991)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>MolLogP</td>
<td>Wildman and Crippen
<em>JCICS</em>
<strong>39</strong>:868-73
(1999)</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>MolMR</td>
<td>Wildman and Crippen
<em>JCICS</em>
<strong>39</strong>:868-73
(1999)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>MolWt</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>ExactMolWt</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>HeavyAtomCount</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>HeavyAtomMolWt</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>NHOHCount</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>NOCount</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>NumHAcceptors</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>NumHDonors</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>NumHeteroatoms</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>NumRotatableBonds</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>NumValenceElectrons</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>NumAmideBonds</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>Num{Aromatic,Saturated,Aliphatic}Rings</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Num{Aromatic,Saturated,Aliphatic}{Hetero,Carbo}cycles</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>RingCount</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>FractionCSP3</td>
<td>&#160;</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>NumSpiroAtoms</td>
<td><blockquote class="first">
<div>Number of spiro atoms</div></blockquote>
<p class="last">(atoms shared between rings that share
exactly one atom)</p>
</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>NumBridgeheadAtoms</td>
<td>Number of bridgehead atoms
(atoms shared between rings that share
at least two bonds)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>TPSA</td>
<td><em>J. Med. Chem.</em>
<strong>43</strong>:3714-7,
(2000)</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>LabuteASA</td>
<td><em>J. Mol. Graph. Mod.</em>
<strong>18</strong>:464-77 (2000)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>PEOE_VSA1 - PEOE_VSA14</td>
<td>MOE-type descriptors using partial charges
and surface area contributions
<a class="reference external" href="http://www.chemcomp.com/journal/vsadesc.htm">http://www.chemcomp.com/journal/vsadesc.htm</a></td>
<td>C++</td>
</tr>
<tr class="row-even"><td>SMR_VSA1 - SMR_VSA10</td>
<td>MOE-type descriptors using MR
contributions and surface area
contributions
<a class="reference external" href="http://www.chemcomp.com/journal/vsadesc.htm">http://www.chemcomp.com/journal/vsadesc.htm</a></td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>SlogP_VSA1 - SlogP_VSA12</td>
<td>MOE-type descriptors using LogP
contributions and surface area
contributions
<a class="reference external" href="http://www.chemcomp.com/journal/vsadesc.htm">http://www.chemcomp.com/journal/vsadesc.htm</a></td>
<td>C++</td>
</tr>
<tr class="row-even"><td>EState_VSA1 - EState_VSA11</td>
<td>MOE-type descriptors using EState indices
and surface area contributions (developed
at RD, not described in the CCG paper)</td>
<td>Python</td>
</tr>
<tr class="row-odd"><td>VSA_EState1 - VSA_EState10</td>
<td>MOE-type descriptors using EState indices
and surface area contributions (developed
at RD, not described in the CCG paper)</td>
<td>Python</td>
</tr>
<tr class="row-even"><td>MQNs</td>
<td>Nguyen et al. <em>ChemMedChem</em> <strong>4</strong>:1803-5
(2009)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>Topliss fragments</td>
<td>implemented using a set of SMARTS
definitions in
$(RDBASE)/Data/FragmentDescriptors.csv</td>
<td>Python</td>
</tr>
<tr class="row-even"><td>Autocorr2D</td>
<td>New in 2017.09 release. Todeschini and Consoni 「Descriptors
from Molecular Geometry」 Handbook of Chemoinformatics
<a class="reference external" href="http://dx.doi.org/10.1002/9783527618279.ch37">http://dx.doi.org/10.1002/9783527618279.ch37</a></td>
<td>C++</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="list-of-available-3d-descriptors">
<h2>List of Available 3D Descriptors<a class="headerlink" href="#list-of-available-3d-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>These all require the molecule to have a 3D conformer.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="49%" />
<col width="8%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Descriptor/Descriptor
Family</td>
<td>Notes</td>
<td>Language</td>
</tr>
<tr class="row-even"><td>Plane of best fit (PBF)</td>
<td>Nicholas C. Firth, Nathan Brown, and Julian
Blagg, <em>JCIM</em> <strong>52</strong>:2516-25</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>PMI1, PMI2, PMI3</td>
<td>Principal moments of inertia</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>NPR1, NPR2</td>
<td>Normalized principal moments ratios Sauer
and Schwarz <em>JCIM</em> <strong>43</strong>:987-1003 (2003)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>Radius of gyration</td>
<td>G. A. Arteca 「Molecular Shape Descriptors」
Reviews in Computational Chemistry vol 9
<a class="reference external" href="http://dx.doi.org/10.1002/9780470125861.ch5">http://dx.doi.org/10.1002/9780470125861.ch5</a></td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Inertial shape factor</td>
<td>Todeschini and Consoni 「Descriptors from Molecular Geometry」
Handbook of Chemoinformatics
<a class="reference external" href="http://dx.doi.org/10.1002/9783527618279.ch37">http://dx.doi.org/10.1002/9783527618279.ch37</a></td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>Eccentricity</td>
<td>G. A. Arteca 「Molecular Shape Descriptors」
Reviews in Computational Chemistry vol 9
<a class="reference external" href="http://dx.doi.org/10.1002/9780470125861.ch5">http://dx.doi.org/10.1002/9780470125861.ch5</a></td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Asphericity</td>
<td>A. Baumgaertner, 「Shapes of flexible vesicles」
J. Chem. Phys. 98:7496
(1993)
<a class="reference external" href="http://dx.doi.org/10.1063/1.464689">http://dx.doi.org/10.1063/1.464689</a></td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>Spherocity Index</td>
<td>Todeschini and Consoni 「Descriptors from Molecular Geometry」
Handbook of Chemoinformatics
<a class="reference external" href="http://dx.doi.org/10.1002/9783527618279.ch37">http://dx.doi.org/10.1002/9783527618279.ch37</a></td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Autocorr3D</td>
<td>New in 2017.09 release. Todeschini and Consoni 「Descriptors
from Molecular Geometry」 Handbook of Chemoinformatics
<a class="reference external" href="http://dx.doi.org/10.1002/9783527618279.ch37">http://dx.doi.org/10.1002/9783527618279.ch37</a></td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>RDF</td>
<td>New in 2017.09 release. Todeschini and Consoni 「Descriptors
from Molecular Geometry」 Handbook of Chemoinformatics
<a class="reference external" href="http://dx.doi.org/10.1002/9783527618279.ch37">http://dx.doi.org/10.1002/9783527618279.ch37</a></td>
<td>C++</td>
</tr>
<tr class="row-even"><td>MORSE</td>
<td>New in 2017.09 release. Todeschini and Consoni 「Descriptors
from Molecular Geometry」 Handbook of Chemoinformatics
<a class="reference external" href="http://dx.doi.org/10.1002/9783527618279.ch37">http://dx.doi.org/10.1002/9783527618279.ch37</a></td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>WHIM</td>
<td><p class="first">New in 2017.09 release. Todeschini and Consoni 「Descriptors
from Molecular Geometry」 Handbook of Chemoinformatics
<a class="reference external" href="http://dx.doi.org/10.1002/9783527618279.ch37">http://dx.doi.org/10.1002/9783527618279.ch37</a></p>
<p class="last"><strong>Note</strong> insufficient information is available to exactly
reproduce values from DRAGON for these descriptors. We
believe that this is close.</p>
</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>GETAWAY</td>
<td><p class="first">New in 2017.09 release. Todeschini and Consoni 「Descriptors
from Molecular Geometry」 Handbook of Chemoinformatics
<a class="reference external" href="http://dx.doi.org/10.1002/9783527618279.ch37">http://dx.doi.org/10.1002/9783527618279.ch37</a></p>
<p class="last"><strong>Note</strong> insufficient information is available to exactly
reproduce values from DRAGON for these descriptors. We
believe that this is close.</p>
</td>
<td>C++</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="list-of-available-fingerprints">
<h2>List of Available Fingerprints<a class="headerlink" href="#list-of-available-fingerprints" title="このヘッドラインへのパーマリンク">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="77%" />
<col width="7%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Fingerprint Type</td>
<td>Notes</td>
<td>Language</td>
</tr>
<tr class="row-even"><td>RDKit</td>
<td>a Daylight-like fingerprint based on hashing molecular subgraphs</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>Atom Pairs</td>
<td><em>JCICS</em> <strong>25</strong>:64-73 (1985)</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Topological Torsions</td>
<td><em>JCICS</em> <strong>27</strong>:82-5 (1987)</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>MACCS keys</td>
<td>Using the 166 public keys implemented as SMARTS</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Morgan/Circular</td>
<td>Fingerprints based on the Morgan algorithm, similar to the ECFP/FCFP fingerprints
<em>JCIM</em> <strong>50</strong>:742-54 (2010).</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>2D Pharmacophore</td>
<td>Uses topological distances between pharmacophoric points.</td>
<td>C++</td>
</tr>
<tr class="row-even"><td>Pattern</td>
<td>a topological fingerprint optimized for substructure screening</td>
<td>C++</td>
</tr>
<tr class="row-odd"><td>Extended Reduced
Graphs</td>
<td>Derived from the ErG fingerprint published by Stiefl et al. in
<em>JCIM</em> <strong>46</strong>:208–20 (2006).
NOTE: these functions return an array of floats, not the usual fingerprint types</td>
<td>C++</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="feature-definitions-used-in-the-morgan-fingerprints">
<h2>Feature Definitions Used in the Morgan Fingerprints<a class="headerlink" href="#feature-definitions-used-in-the-morgan-fingerprints" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>These are adapted from the definitions in Gobbi, A. &amp; Poppinger, D. “Genetic optimization of combinatorial libraries.” <em>Biotechnology and Bioengineering</em> <strong>61</strong>, 47-54 (1998).</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Feature</td>
<td>SMARTS</td>
</tr>
<tr class="row-even"><td>Donor</td>
<td><code class="docutils literal"><span class="pre">[$([N;!H0;v3,v4&amp;+1]),$([O,S;H1;+0]),n&amp;H1&amp;+0]</span></code></td>
</tr>
<tr class="row-odd"><td>Acceptor</td>
<td><code class="docutils literal"><span class="pre">[$([O,S;H1;v2;!$(*-*=[O,N,P,S])]),$([O,S;H0;v2]),$([O,S;-]),$([N;v3;!$(N-*=[O,N,P,S])]),n&amp;H0&amp;+0,$([o,s;+0;!$([o,s]:n);!$([o,s]:c:n)])]</span></code></td>
</tr>
<tr class="row-even"><td>Aromatic</td>
<td><code class="docutils literal"><span class="pre">[a]</span></code></td>
</tr>
<tr class="row-odd"><td>Halogen</td>
<td><code class="docutils literal"><span class="pre">[F,Cl,Br,I]</span></code></td>
</tr>
<tr class="row-even"><td>Basic</td>
<td><code class="docutils literal"><span class="pre">[#7;+,$([N;H2&amp;+0][$([C,a]);!$([C,a](=O))]),$([N;H1&amp;+0]([$([C,a]);!$([C,a](=O))])[$([C,a]);!$([C,a](=O))]),$([N;H0&amp;+0]([C;!$(C(=O))])([C;!$(C(=O))])[C;!$(C(=O))])]</span></code></td>
</tr>
<tr class="row-odd"><td>Acidic</td>
<td><code class="docutils literal"><span class="pre">[$([C,S](=[O,S,P])-[O;H1,-1])]</span></code></td>
</tr>
</tbody>
</table>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="blaney" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Blaney, J. M.; Dixon, J. S. 「Distance Geometry in Molecular Modeling」.  <em>Reviews in Computational Chemistry</em>; VCH: New York, 1994.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rappe" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Rappé, A. K.; Casewit, C. J.; Colwell, K. S.; Goddard III, W. A.; Skiff, W. M. 「UFF, a full periodic table force field for molecular mechanics and molecular dynamics simulations」. <em>J. Am. Chem. Soc.</em> <strong>114</strong>:10024-35 (1992) .</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="carhart" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[3]</a></td><td>Carhart, R.E.; Smith, D.H.; Venkataraghavan R. “Atom Pairs as Molecular Features in Structure-Activity Studies: Definition and Applications” <em>J. Chem. Inf. Comp. Sci.</em> <strong>25</strong>:64-73 (1985).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="nilakantan" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[4]</a></td><td>Nilakantan, R.; Bauman N.; Dixon J.S.; Venkataraghavan R. “Topological Torsion: A New Molecular Descriptor for SAR Applications. Comparison with Other Desciptors.” <em>J. Chem.Inf. Comp. Sci.</em> <strong>27</strong>:82-5 (1987).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rogers" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[5]</a></td><td>Rogers, D.; Hahn, M. “Extended-Connectivity Fingerprints.” <em>J. Chem. Inf. and Model.</em> <strong>50</strong>:742-54 (2010).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ashton" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[6]</a></td><td>Ashton, M. et al. “Identification of Diverse Database Subsets using Property-Based and Fragment-Based Molecular Descriptions.” <em>Quantitative Structure-Activity Relationships</em> <strong>21</strong>:598-604 (2002).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bemis1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[7]</a></td><td>Bemis, G. W.; Murcko, M. A. 「The Properties of Known Drugs. 1. Molecular Frameworks.」 <em>J. Med. Chem.</em>  <strong>39</strong>:2887-93 (1996).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="lewell" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[8]</a></td><td>Lewell, X.Q.; Judd, D.B.; Watson, S.P.; Hann, M.M. “RECAP-Retrosynthetic Combinatorial Analysis Procedure: A Powerful New Technique for Identifying Privileged Molecular Fragments with Useful Applications in Combinatorial Chemistry” <em>J. Chem. Inf. Comp. Sci.</em> <strong>38</strong>:511-22 (1998).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="degen" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[9]</a></td><td>Degen, J.; Wegscheid-Gerlach, C.; Zaliani, A; Rarey, M. 「On the Art of Compiling and Using ‘Drug-Like’ Chemical Fragment Spaces.」 <em>ChemMedChem</em> <strong>3</strong>:1503–7 (2008).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gobbi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[10]</a></td><td>Gobbi, A. &amp; Poppinger, D. 「Genetic optimization of combinatorial libraries.」 <em>Biotechnology and Bioengineering</em> <strong>61</strong>:47-54 (1998).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rxnsmarts" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[11]</a></td><td>A more detailed description of reaction smarts, as defined by the rdkit, is in the <a class="reference internal" href="RDKit_Book.html"><span class="doc">The RDKit Book</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mmff1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[12]</a></td><td>Halgren, T. A. 「Merck molecular force field. I. Basis, form, scope, parameterization, and performance of MMFF94.」 <em>J. Comp. Chem.</em> <strong>17</strong>:490–19 (1996).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mmff2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[13]</a></td><td>Halgren, T. A. 「Merck molecular force field. II. MMFF94 van der Waals and electrostatic parameters for intermolecular interactions.」 <em>J. Comp. Chem.</em> <strong>17</strong>:520–52 (1996).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mmff3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[14]</a></td><td>Halgren, T. A. 「Merck molecular force field. III. Molecular geometries and vibrational frequencies for MMFF94.」 <em>J. Comp. Chem.</em> <strong>17</strong>:553–86 (1996).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mmff4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[15]</a></td><td>Halgren, T. A. &amp; Nachbar, R. B. 「Merck molecular force field. IV. conformational energies and geometries for MMFF94.」 <em>J. Comp. Chem.</em> <strong>17</strong>:587-615 (1996).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mmffs" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[16]</a></td><td>Halgren, T. A. 「MMFF VI. MMFF94s option for energy minimization studies.」 <em>J. Comp. Chem.</em> <strong>20</strong>:720–9 (1999).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="riniker" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[17]</a></td><td>Riniker, S.; Landrum, G. A. 「Similarity Maps - A Visualization Strategy for Molecular Fingerprints and Machine-Learning Methods」 <em>J. Cheminf.</em> <strong>5</strong>:43 (2013).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="riniker2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[18]</a></td><td>Riniker, S.; Landrum, G. A. 「Better Informed Distance Geometry: Using What We Know To Improve Conformation Generation」 <em>J. Chem. Inf. Comp. Sci.</em> <strong>55</strong>:2562-74 (2015)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="license">
<h2>License<a class="headerlink" href="#license" title="このヘッドラインへのパーマリンク">¶</a></h2>
<img alt="_images/picture_5.png" src="_images/picture_5.png" />
<p>This document is copyright (C) 2007-2016 by Greg Landrum</p>
<p>This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 License.
To view a copy of this license, visit <a class="reference external" href="http://creativecommons.org/licenses/by-sa/4.0/">http://creativecommons.org/licenses/by-sa/4.0/</a> or send a letter to Creative Commons, 543 Howard Street, 5th Floor, San Francisco, California, 94105, USA.</p>
<p>The intent of this license is similar to that of the RDKit itself.
In simple words: “Do whatever you want with it, but please give us some credit.”</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="RDKit_Book.html" title="The RDKit Book"
             >次へ</a> |</li>
        <li class="right" >
          <a href="Install.html" title="Installation"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">The RDKit 2017.09.2 ドキュメント</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Greg Landrum.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6 で生成しました。
    </div>
  </body>
</html>