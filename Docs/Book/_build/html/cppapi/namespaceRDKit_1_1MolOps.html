<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RDKit: RDKit::MolOps Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_plain.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RDKit
   </div>
   <div id="projectbrief">Open-source cheminformatics and machine learning.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceRDKit_1_1MolOps.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RDKit::MolOps Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Groups a variety of molecular query and transformation operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRDKit_1_1MolOps_1_1AdjustQueryParameters.html">AdjustQueryParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a66f4444c887732f3d1c9c8acd3b7de12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a66f4444c887732f3d1c9c8acd3b7de12">countAtomElec</a> (const <a class="el" href="classRDKit_1_1Atom.html">Atom</a> *at)</td></tr>
<tr class="memdesc:a66f4444c887732f3d1c9c8acd3b7de12"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of electrons available on an atom to donate for  <a href="#a66f4444c887732f3d1c9c8acd3b7de12">More...</a><br /></td></tr>
<tr class="separator:a66f4444c887732f3d1c9c8acd3b7de12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383f0b5365adccf4810682f44f1e519c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a383f0b5365adccf4810682f44f1e519c">getFormalCharge</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol)</td></tr>
<tr class="memdesc:a383f0b5365adccf4810682f44f1e519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">sums up all atomic formal charges and returns the result  <a href="#a383f0b5365adccf4810682f44f1e519c">More...</a><br /></td></tr>
<tr class="separator:a383f0b5365adccf4810682f44f1e519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4728b78ba77bf1662b1c74b1045a7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#abf4728b78ba77bf1662b1c74b1045a7d">atomHasConjugatedBond</a> (const <a class="el" href="classRDKit_1_1Atom.html">Atom</a> *at)</td></tr>
<tr class="memdesc:abf4728b78ba77bf1662b1c74b1045a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether or not the given <a class="el" href="classRDKit_1_1Atom.html" title="The class for representing atoms. ">Atom</a> is involved in a conjugated bond  <a href="#abf4728b78ba77bf1662b1c74b1045a7d">More...</a><br /></td></tr>
<tr class="separator:abf4728b78ba77bf1662b1c74b1045a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8100d785d32fb3c173b83949766b87b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#ad8100d785d32fb3c173b83949766b87b">getMolFrags</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, std::vector&lt; int &gt; &amp;mapping)</td></tr>
<tr class="memdesc:ad8100d785d32fb3c173b83949766b87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">find fragments (disconnected components of the molecular graph)  <a href="#ad8100d785d32fb3c173b83949766b87b">More...</a><br /></td></tr>
<tr class="separator:ad8100d785d32fb3c173b83949766b87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2812dd5ae2d896a76f7c3e53df00e655"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a2812dd5ae2d896a76f7c3e53df00e655">getMolFrags</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;frags)</td></tr>
<tr class="memdesc:a2812dd5ae2d896a76f7c3e53df00e655"><td class="mdescLeft">&#160;</td><td class="mdescRight">find fragments (disconnected components of the molecular graph)  <a href="#a2812dd5ae2d896a76f7c3e53df00e655">More...</a><br /></td></tr>
<tr class="separator:a2812dd5ae2d896a76f7c3e53df00e655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961d74791d3a7670fa336a0e8a5b821e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a961d74791d3a7670fa336a0e8a5b821e">getMolFrags</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool sanitizeFrags=true, std::vector&lt; int &gt; *frags=0, std::vector&lt; std::vector&lt; int &gt; &gt; *fragsMolAtomMapping=0, bool copyConformers=true)</td></tr>
<tr class="memdesc:a961d74791d3a7670fa336a0e8a5b821e"><td class="mdescLeft">&#160;</td><td class="mdescRight">splits a molecule into its component fragments  <a href="#a961d74791d3a7670fa336a0e8a5b821e">More...</a><br /></td></tr>
<tr class="separator:a961d74791d3a7670fa336a0e8a5b821e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fd7c52b582bfcc1e0578c4190c9154"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1fd7c52b582bfcc1e0578c4190c9154"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; T, boost::shared_ptr&lt; <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#aa1fd7c52b582bfcc1e0578c4190c9154">getMolFragsWithQuery</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, T(*query)(const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;, const <a class="el" href="classRDKit_1_1Atom.html">Atom</a> *), bool sanitizeFrags=true, const std::vector&lt; T &gt; *whiteList=0, bool negateList=false)</td></tr>
<tr class="memdesc:aa1fd7c52b582bfcc1e0578c4190c9154"><td class="mdescLeft">&#160;</td><td class="mdescRight">splits a molecule into pieces based on labels assigned using a query  <a href="#aa1fd7c52b582bfcc1e0578c4190c9154">More...</a><br /></td></tr>
<tr class="separator:aa1fd7c52b582bfcc1e0578c4190c9154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb79c3c6379aac4e7a5d215751b6205e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#afb79c3c6379aac4e7a5d215751b6205e">computeBalabanJ</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool useBO=true, bool force=false, const std::vector&lt; int &gt; *bondPath=0, bool cacheIt=true)</td></tr>
<tr class="memdesc:afb79c3c6379aac4e7a5d215751b6205e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates Balaban's J index for the molecule  <a href="#afb79c3c6379aac4e7a5d215751b6205e">More...</a><br /></td></tr>
<tr class="separator:afb79c3c6379aac4e7a5d215751b6205e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974904ad303124381600fb218df3e1b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a974904ad303124381600fb218df3e1b0">computeBalabanJ</a> (double *distMat, int nb, int nAts)</td></tr>
<tr class="separator:a974904ad303124381600fb218df3e1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72217aa97105f29efcb1d710380a761c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a72217aa97105f29efcb1d710380a761c">getNumAtomsWithDistinctProperty</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, std::string prop)</td></tr>
<tr class="memdesc:a72217aa97105f29efcb1d710380a761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of atoms which have a particular property set  <a href="#a72217aa97105f29efcb1d710380a761c">More...</a><br /></td></tr>
<tr class="separator:a72217aa97105f29efcb1d710380a761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Ring finding and SSSR</div></td></tr>
<tr class="memitem:ae6e866d1a5ef24aa76a0f5f9ab5217da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#ae6e866d1a5ef24aa76a0f5f9ab5217da">findSSSR</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;res)</td></tr>
<tr class="memdesc:ae6e866d1a5ef24aa76a0f5f9ab5217da"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a molecule's Smallest Set of Smallest Rings  <a href="#ae6e866d1a5ef24aa76a0f5f9ab5217da">More...</a><br /></td></tr>
<tr class="separator:ae6e866d1a5ef24aa76a0f5f9ab5217da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ac47e7ee6af9869a0c2fd84b617d39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a14ac47e7ee6af9869a0c2fd84b617d39">findSSSR</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, std::vector&lt; std::vector&lt; int &gt; &gt; *res=0)</td></tr>
<tr class="separator:a14ac47e7ee6af9869a0c2fd84b617d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4723058e660ef77a806981f542003c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#aeb4723058e660ef77a806981f542003c">fastFindRings</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol)</td></tr>
<tr class="memdesc:aeb4723058e660ef77a806981f542003c"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a DFS algorithm to identify ring bonds and atoms in a molecule  <a href="#aeb4723058e660ef77a806981f542003c">More...</a><br /></td></tr>
<tr class="separator:aeb4723058e660ef77a806981f542003c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032bdc967b1d512bfbf1c36c0f0d6a31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a032bdc967b1d512bfbf1c36c0f0d6a31">symmetrizeSSSR</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;res)</td></tr>
<tr class="memdesc:a032bdc967b1d512bfbf1c36c0f0d6a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">symmetrize the molecule's Smallest Set of Smallest Rings  <a href="#a032bdc967b1d512bfbf1c36c0f0d6a31">More...</a><br /></td></tr>
<tr class="separator:a032bdc967b1d512bfbf1c36c0f0d6a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5e8e6d6dae2c1c6ad93ee3a00c2911"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a3c5e8e6d6dae2c1c6ad93ee3a00c2911">symmetrizeSSSR</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol)</td></tr>
<tr class="separator:a3c5e8e6d6dae2c1c6ad93ee3a00c2911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shortest paths and other matrices</div></td></tr>
<tr class="memitem:a41721af9789cc1c1622c09f7a615c852"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a41721af9789cc1c1622c09f7a615c852">getAdjacencyMatrix</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool useBO=false, int emptyVal=0, bool force=false, const char *propNamePrefix=0, const boost::dynamic_bitset&lt;&gt; *bondsToUse=0)</td></tr>
<tr class="memdesc:a41721af9789cc1c1622c09f7a615c852"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a molecule's adjacency matrix  <a href="#a41721af9789cc1c1622c09f7a615c852">More...</a><br /></td></tr>
<tr class="separator:a41721af9789cc1c1622c09f7a615c852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7077523543dc110f22c90a6cb9790b1a"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a7077523543dc110f22c90a6cb9790b1a">getDistanceMat</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool useBO=false, bool useAtomWts=false, bool force=false, const char *propNamePrefix=0)</td></tr>
<tr class="memdesc:a7077523543dc110f22c90a6cb9790b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the molecule's topological distance matrix.  <a href="#a7077523543dc110f22c90a6cb9790b1a">More...</a><br /></td></tr>
<tr class="separator:a7077523543dc110f22c90a6cb9790b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f6a3c606682fe0393b9b859cced79b"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a02f6a3c606682fe0393b9b859cced79b">getDistanceMat</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, const std::vector&lt; int &gt; &amp;activeAtoms, const std::vector&lt; const <a class="el" href="classRDKit_1_1Bond.html">Bond</a> * &gt; &amp;bonds, bool useBO=false, bool useAtomWts=false)</td></tr>
<tr class="memdesc:a02f6a3c606682fe0393b9b859cced79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the molecule's topological distance matrix.  <a href="#a02f6a3c606682fe0393b9b859cced79b">More...</a><br /></td></tr>
<tr class="separator:a02f6a3c606682fe0393b9b859cced79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2417ccad3a2df24479fbd576ba71e0"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a6f2417ccad3a2df24479fbd576ba71e0">get3DDistanceMat</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, int confId=-1, bool useAtomWts=false, bool force=false, const char *propNamePrefix=0)</td></tr>
<tr class="memdesc:a6f2417ccad3a2df24479fbd576ba71e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the molecule's 3D distance matrix.  <a href="#a6f2417ccad3a2df24479fbd576ba71e0">More...</a><br /></td></tr>
<tr class="separator:a6f2417ccad3a2df24479fbd576ba71e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c563124730b9be240998dfc49e7509"><td class="memItemLeft" align="right" valign="top">std::list&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a00c563124730b9be240998dfc49e7509">getShortestPath</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, int aid1, int aid2)</td></tr>
<tr class="memdesc:a00c563124730b9be240998dfc49e7509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the shortest path between two atoms.  <a href="#a00c563124730b9be240998dfc49e7509">More...</a><br /></td></tr>
<tr class="separator:a00c563124730b9be240998dfc49e7509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stereochemistry</div></td></tr>
<tr class="memitem:a4f4af272ca8a5ccb54199ed7584f286a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a4f4af272ca8a5ccb54199ed7584f286a">cleanupChirality</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol)</td></tr>
<tr class="memdesc:a4f4af272ca8a5ccb54199ed7584f286a"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes bogus chirality markers (those on non-sp3 centers):  <a href="#a4f4af272ca8a5ccb54199ed7584f286a">More...</a><br /></td></tr>
<tr class="separator:a4f4af272ca8a5ccb54199ed7584f286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582691ed74d9962b18db6bca0b1d6a81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a582691ed74d9962b18db6bca0b1d6a81">assignChiralTypesFrom3D</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, int confId=-1, bool replaceExistingTags=true)</td></tr>
<tr class="memdesc:a582691ed74d9962b18db6bca0b1d6a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a conformer to assign ChiralType to a molecule's atoms.  <a href="#a582691ed74d9962b18db6bca0b1d6a81">More...</a><br /></td></tr>
<tr class="separator:a582691ed74d9962b18db6bca0b1d6a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d126c8da82e0ee29d586e615f26e8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#af8d126c8da82e0ee29d586e615f26e8e">assignStereochemistryFrom3D</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, int confId=-1, bool replaceExistingTags=true)</td></tr>
<tr class="memdesc:af8d126c8da82e0ee29d586e615f26e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a conformer to assign ChiralTypes to a molecule's atoms and stereo flags to its bonds.  <a href="#af8d126c8da82e0ee29d586e615f26e8e">More...</a><br /></td></tr>
<tr class="separator:af8d126c8da82e0ee29d586e615f26e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992d63a45590b287f310a88228659991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a992d63a45590b287f310a88228659991">detectBondStereochemistry</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, int confId=-1)</td></tr>
<tr class="memdesc:a992d63a45590b287f310a88228659991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a conformer to assign directionality to the single bonds around double bonds.  <a href="#a992d63a45590b287f310a88228659991">More...</a><br /></td></tr>
<tr class="separator:a992d63a45590b287f310a88228659991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae38bdd181c070deee55a4d3ee12885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#abae38bdd181c070deee55a4d3ee12885">assignStereochemistry</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool cleanIt=false, bool force=false, bool flagPossibleStereoCenters=false)</td></tr>
<tr class="memdesc:abae38bdd181c070deee55a4d3ee12885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign stereochemistry tags to atoms (i.e. R/S) and bonds (i.e. Z/E)  <a href="#abae38bdd181c070deee55a4d3ee12885">More...</a><br /></td></tr>
<tr class="separator:abae38bdd181c070deee55a4d3ee12885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaea0d3a71758b1598a1be8df2171edf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#aaaea0d3a71758b1598a1be8df2171edf">removeStereochemistry</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol)</td></tr>
<tr class="memdesc:aaaea0d3a71758b1598a1be8df2171edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all stereochemistry information from atoms (i.e. R/S) and bonds.  <a href="#aaaea0d3a71758b1598a1be8df2171edf">More...</a><br /></td></tr>
<tr class="separator:aaaea0d3a71758b1598a1be8df2171edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e8a8839c4fb4368631a778e40812ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a11e8a8839c4fb4368631a778e40812ea">findPotentialStereoBonds</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool cleanIt=false)</td></tr>
<tr class="memdesc:a11e8a8839c4fb4368631a778e40812ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds bonds that could be cis/trans in a molecule and mark them as <a class="el" href="classRDKit_1_1Bond.html#ae91dd8e72b495a48f46775c874882165ae9c6ddb21e39393f9e57eb5cbdd8b6a1">Bond::STEREOANY</a>.  <a href="#a11e8a8839c4fb4368631a778e40812ea">More...</a><br /></td></tr>
<tr class="separator:a11e8a8839c4fb4368631a778e40812ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with hydrogens</h2></td></tr>
<tr class="memitem:afdde916834c23b0369e8df1f99da6ba4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4">AdjustQueryWhichFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4a540015fc38ccc05156f882bfe531397a">ADJUST_IGNORENONE</a> = 0x0, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4acf2813a23e49ec9d0f266cf6a0823c99">ADJUST_IGNORECHAINS</a> = 0x1, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4a0b3c088497c14c40b3e5526e46507e5c">ADJUST_IGNORERINGS</a> = 0x4, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4ab15b67d2d611481ec3a66b8ce65991e5">ADJUST_IGNOREDUMMIES</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4aa7216b78564da0dd77a35a612802a540">ADJUST_IGNORENONDUMMIES</a> = 0x8, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4a6e2979fce08ce7dc3e29dbe113df21fe">ADJUST_IGNOREMAPPED</a> = 0x10, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4ae32f38b63cedc6eb6de9b19883b0692c">ADJUST_IGNOREALL</a> = 0xFFFFFFF
<br />
 }</td></tr>
<tr class="separator:afdde916834c23b0369e8df1f99da6ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c82d305de578c527eb020669e5ec2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a1c82d305de578c527eb020669e5ec2ac">addHs</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool explicitOnly=false, bool addCoords=false, const <a class="el" href="namespaceRDKit.html#afd4685678f15f708c0402588adbd5bf7">UINT_VECT</a> *onlyOnAtoms=NULL)</td></tr>
<tr class="memdesc:a1c82d305de578c527eb020669e5ec2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a copy of a molecule with hydrogens added in as explicit Atoms  <a href="#a1c82d305de578c527eb020669e5ec2ac">More...</a><br /></td></tr>
<tr class="separator:a1c82d305de578c527eb020669e5ec2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98881884511b4af3bc4958b95530f850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a98881884511b4af3bc4958b95530f850">addHs</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol, bool explicitOnly=false, bool addCoords=false, const <a class="el" href="namespaceRDKit.html#afd4685678f15f708c0402588adbd5bf7">UINT_VECT</a> *onlyOnAtoms=NULL)</td></tr>
<tr class="separator:a98881884511b4af3bc4958b95530f850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af107496a733ec110568d56b46e6a85fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#af107496a733ec110568d56b46e6a85fe">removeHs</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool implicitOnly=false, bool updateExplicitCount=false, bool sanitize=true)</td></tr>
<tr class="memdesc:af107496a733ec110568d56b46e6a85fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a copy of a molecule with hydrogens removed  <a href="#af107496a733ec110568d56b46e6a85fe">More...</a><br /></td></tr>
<tr class="separator:af107496a733ec110568d56b46e6a85fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6910ee11522058972aaf5d882f0c965a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a6910ee11522058972aaf5d882f0c965a">removeHs</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol, bool implicitOnly=false, bool updateExplicitCount=false, bool sanitize=true)</td></tr>
<tr class="separator:a6910ee11522058972aaf5d882f0c965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eb4f320aefffa2f90ad625465588eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a94eb4f320aefffa2f90ad625465588eb">mergeQueryHs</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, bool mergeUnmappedOnly=false)</td></tr>
<tr class="separator:a94eb4f320aefffa2f90ad625465588eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3b2fd7381895536a4199e411238d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a7b3b2fd7381895536a4199e411238d79">mergeQueryHs</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol, bool mergeUnmappedOnly=false)</td></tr>
<tr class="separator:a7b3b2fd7381895536a4199e411238d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad969f50ae36c9978b0788b0627ac6544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#ad969f50ae36c9978b0788b0627ac6544">adjustQueryProperties</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, const <a class="el" href="structRDKit_1_1MolOps_1_1AdjustQueryParameters.html">AdjustQueryParameters</a> *params=NULL)</td></tr>
<tr class="memdesc:ad969f50ae36c9978b0788b0627ac6544"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a copy of a molecule with query properties adjusted  <a href="#ad969f50ae36c9978b0788b0627ac6544">More...</a><br /></td></tr>
<tr class="separator:ad969f50ae36c9978b0788b0627ac6544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e97eb4d0e5e2ee77117bd3d554cb84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#ac3e97eb4d0e5e2ee77117bd3d554cb84">adjustQueryProperties</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol, const <a class="el" href="structRDKit_1_1MolOps_1_1AdjustQueryParameters.html">AdjustQueryParameters</a> *params=NULL)</td></tr>
<tr class="separator:ac3e97eb4d0e5e2ee77117bd3d554cb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96649cb8953d6b3ab6dfd43f639cafd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a96649cb8953d6b3ab6dfd43f639cafd1">renumberAtoms</a> (const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol, const std::vector&lt; unsigned int &gt; &amp;newOrder)</td></tr>
<tr class="memdesc:a96649cb8953d6b3ab6dfd43f639cafd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a copy of a molecule with the atoms renumbered  <a href="#a96649cb8953d6b3ab6dfd43f639cafd1">More...</a><br /></td></tr>
<tr class="separator:a96649cb8953d6b3ab6dfd43f639cafd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Sanitization</h2></td></tr>
<tr class="memitem:a84fb27eb77609bdfe7e1c00a41f3494f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494f">SanitizeFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa61de781c40dab9ead376f7796025d4cd">SANITIZE_NONE</a> = 0x0, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fafeb1a1b49158f0b0bf048ebeca3da95c">SANITIZE_CLEANUP</a> = 0x1, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa75743fcaf2b2aa803413aa3ee15e52e0">SANITIZE_PROPERTIES</a> = 0x2, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa88db8f204ab939b6f818c4b77decab03">SANITIZE_SYMMRINGS</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fadb542a5504cc6054dc34b913223dd4e3">SANITIZE_KEKULIZE</a> = 0x8, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fad5dec5afcd29998f33389e457cfa9c89">SANITIZE_FINDRADICALS</a> = 0x10, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa0781fa20a55012958e306db5f11f28e0">SANITIZE_SETAROMATICITY</a> = 0x20, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa7fb396182390cac33cb19790b6141de4">SANITIZE_SETCONJUGATION</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fae6946df9e0bc9cf1497b956ad7578274">SANITIZE_SETHYBRIDIZATION</a> = 0x80, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fad006f849064cd8cdeec1677e9ac14c2f">SANITIZE_CLEANUPCHIRALITY</a> = 0x100, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa9fed76ebbec9647c11d5a309cb7f039d">SANITIZE_ADJUSTHS</a> = 0x200, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa0250c83e840bd3708e4e0a9516667538">SANITIZE_ALL</a> = 0xFFFFFFF
<br />
 }</td></tr>
<tr class="separator:a84fb27eb77609bdfe7e1c00a41f3494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcbb725ec35a926b18aa7938fcea3ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ec">AromaticityModel</a> { <a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ecac7d815cbfd690b24d6888a655456c939">AROMATICITY_DEFAULT</a> = 0x0, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3eca029375bd5cd541a6cd7450fffee35511">AROMATICITY_RDKIT</a> = 0x1, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ecadf7f404317c19cb94734e4917550c0cd">AROMATICITY_SIMPLE</a> = 0x2, 
<a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ecab767ac61b6b43cf85c4a95b16848dcf9">AROMATICITY_CUSTOM</a> = 0xFFFFFFF
 }<tr class="memdesc:a3dcbb725ec35a926b18aa7938fcea3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible aromaticity models.  <a href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ec">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3dcbb725ec35a926b18aa7938fcea3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb89201d884ccf4ed79328f9b4ebce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#afeb89201d884ccf4ed79328f9b4ebce8">sanitizeMol</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol, unsigned int &amp;operationThatFailed, unsigned int sanitizeOps=<a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa0250c83e840bd3708e4e0a9516667538">SANITIZE_ALL</a>)</td></tr>
<tr class="memdesc:afeb89201d884ccf4ed79328f9b4ebce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">carries out a collection of tasks for cleaning up a molecule and  <a href="#afeb89201d884ccf4ed79328f9b4ebce8">More...</a><br /></td></tr>
<tr class="separator:afeb89201d884ccf4ed79328f9b4ebce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62db8a3732ccd00ef4b7f52517f2c5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#aa62db8a3732ccd00ef4b7f52517f2c5d">sanitizeMol</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol)</td></tr>
<tr class="separator:aa62db8a3732ccd00ef4b7f52517f2c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1e9490835888ac4afb636354906e1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#acb1e9490835888ac4afb636354906e1d">setAromaticity</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol, <a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ec">AromaticityModel</a> model=<a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ecac7d815cbfd690b24d6888a655456c939">AROMATICITY_DEFAULT</a>, int(*func)(<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;)=NULL)</td></tr>
<tr class="memdesc:acb1e9490835888ac4afb636354906e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the aromaticity for a molecule.  <a href="#acb1e9490835888ac4afb636354906e1d">More...</a><br /></td></tr>
<tr class="separator:acb1e9490835888ac4afb636354906e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83e50cc9f72d5a15408cd8818f87c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#ab83e50cc9f72d5a15408cd8818f87c3d">cleanUp</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol)</td></tr>
<tr class="memdesc:ab83e50cc9f72d5a15408cd8818f87c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Designed to be called by the sanitizer to handle special cases before.  <a href="#ab83e50cc9f72d5a15408cd8818f87c3d">More...</a><br /></td></tr>
<tr class="separator:ab83e50cc9f72d5a15408cd8818f87c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2862a120b5802558e5b99a9d3e142322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a2862a120b5802558e5b99a9d3e142322">assignRadicals</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol)</td></tr>
<tr class="memdesc:a2862a120b5802558e5b99a9d3e142322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the sanitizer to assign radical counts to atoms.  <a href="#a2862a120b5802558e5b99a9d3e142322">More...</a><br /></td></tr>
<tr class="separator:a2862a120b5802558e5b99a9d3e142322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2db5d9d43f2a6f90ffbd552b87d4acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#ae2db5d9d43f2a6f90ffbd552b87d4acf">adjustHs</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol)</td></tr>
<tr class="memdesc:ae2db5d9d43f2a6f90ffbd552b87d4acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the number of implicit and explicit Hs for special cases  <a href="#ae2db5d9d43f2a6f90ffbd552b87d4acf">More...</a><br /></td></tr>
<tr class="separator:ae2db5d9d43f2a6f90ffbd552b87d4acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97703326c0e03b5ce2571db51a4f2d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a97703326c0e03b5ce2571db51a4f2d37">Kekulize</a> (<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;mol, bool markAtomsBonds=true, unsigned int maxBackTracks=100)</td></tr>
<tr class="memdesc:a97703326c0e03b5ce2571db51a4f2d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kekulizes the molecule.  <a href="#a97703326c0e03b5ce2571db51a4f2d37">More...</a><br /></td></tr>
<tr class="separator:a97703326c0e03b5ce2571db51a4f2d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6958f372a9637b1331dcde8bb38b99ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a6958f372a9637b1331dcde8bb38b99ea">setConjugation</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol)</td></tr>
<tr class="memdesc:a6958f372a9637b1331dcde8bb38b99ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">flags the molecule's conjugated bonds  <a href="#a6958f372a9637b1331dcde8bb38b99ea">More...</a><br /></td></tr>
<tr class="separator:a6958f372a9637b1331dcde8bb38b99ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b9724fc353ae2b5f3af2f0664ebf87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRDKit_1_1MolOps.html#a33b9724fc353ae2b5f3af2f0664ebf87">setHybridization</a> (<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;mol)</td></tr>
<tr class="memdesc:a33b9724fc353ae2b5f3af2f0664ebf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates and sets the hybridization of all a molecule's Stoms  <a href="#a33b9724fc353ae2b5f3af2f0664ebf87">More...</a><br /></td></tr>
<tr class="separator:a33b9724fc353ae2b5f3af2f0664ebf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Groups a variety of molecular query and transformation operations. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="afdde916834c23b0369e8df1f99da6ba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRDKit_1_1MolOps.html#afdde916834c23b0369e8df1f99da6ba4">RDKit::MolOps::AdjustQueryWhichFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="afdde916834c23b0369e8df1f99da6ba4a540015fc38ccc05156f882bfe531397a"></a>ADJUST_IGNORENONE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afdde916834c23b0369e8df1f99da6ba4acf2813a23e49ec9d0f266cf6a0823c99"></a>ADJUST_IGNORECHAINS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afdde916834c23b0369e8df1f99da6ba4a0b3c088497c14c40b3e5526e46507e5c"></a>ADJUST_IGNORERINGS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afdde916834c23b0369e8df1f99da6ba4ab15b67d2d611481ec3a66b8ce65991e5"></a>ADJUST_IGNOREDUMMIES&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afdde916834c23b0369e8df1f99da6ba4aa7216b78564da0dd77a35a612802a540"></a>ADJUST_IGNORENONDUMMIES&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afdde916834c23b0369e8df1f99da6ba4a6e2979fce08ce7dc3e29dbe113df21fe"></a>ADJUST_IGNOREMAPPED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afdde916834c23b0369e8df1f99da6ba4ae32f38b63cedc6eb6de9b19883b0692c"></a>ADJUST_IGNOREALL&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="MolOps_8h_source.html#l00246">246</a> of file <a class="el" href="MolOps_8h_source.html">MolOps.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3dcbb725ec35a926b18aa7938fcea3ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ec">RDKit::MolOps::AromaticityModel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible aromaticity models. </p>
<ul>
<li><code>AROMATICITY_DEFAULT</code> at the moment always uses <code>AROMATICITY_RDKIT</code> </li>
<li><code>AROMATICITY_RDKIT</code> is the standard <a class="el" href="namespaceRDKit.html" title="Std stuff. ">RDKit</a> model (as documented in the <a class="el" href="namespaceRDKit.html" title="Std stuff. ">RDKit</a> Book)</li>
<li><code>AROMATICITY_SIMPLE</code> only considers 5- and 6-membered simple rings (it does not consider the outer envelope of fused rings)</li>
<li><code>AROMATICITY_CUSTOM</code> uses a caller-provided function </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3dcbb725ec35a926b18aa7938fcea3ecac7d815cbfd690b24d6888a655456c939"></a>AROMATICITY_DEFAULT&#160;</td><td class="fielddoc">
<p>future proofing </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3dcbb725ec35a926b18aa7938fcea3eca029375bd5cd541a6cd7450fffee35511"></a>AROMATICITY_RDKIT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3dcbb725ec35a926b18aa7938fcea3ecadf7f404317c19cb94734e4917550c0cd"></a>AROMATICITY_SIMPLE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3dcbb725ec35a926b18aa7938fcea3ecab767ac61b6b43cf85c4a95b16848dcf9"></a>AROMATICITY_CUSTOM&#160;</td><td class="fielddoc">
<p>use a function </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="MolOps_8h_source.html#l00390">390</a> of file <a class="el" href="MolOps_8h_source.html">MolOps.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494f">RDKit::MolOps::SanitizeFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fa61de781c40dab9ead376f7796025d4cd"></a>SANITIZE_NONE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fafeb1a1b49158f0b0bf048ebeca3da95c"></a>SANITIZE_CLEANUP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fa75743fcaf2b2aa803413aa3ee15e52e0"></a>SANITIZE_PROPERTIES&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fa88db8f204ab939b6f818c4b77decab03"></a>SANITIZE_SYMMRINGS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fadb542a5504cc6054dc34b913223dd4e3"></a>SANITIZE_KEKULIZE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fad5dec5afcd29998f33389e457cfa9c89"></a>SANITIZE_FINDRADICALS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fa0781fa20a55012958e306db5f11f28e0"></a>SANITIZE_SETAROMATICITY&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fa7fb396182390cac33cb19790b6141de4"></a>SANITIZE_SETCONJUGATION&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fae6946df9e0bc9cf1497b956ad7578274"></a>SANITIZE_SETHYBRIDIZATION&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fad006f849064cd8cdeec1677e9ac14c2f"></a>SANITIZE_CLEANUPCHIRALITY&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fa9fed76ebbec9647c11d5a309cb7f039d"></a>SANITIZE_ADJUSTHS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a84fb27eb77609bdfe7e1c00a41f3494fa0250c83e840bd3708e4e0a9516667538"></a>SANITIZE_ALL&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="MolOps_8h_source.html#l00323">323</a> of file <a class="el" href="MolOps_8h_source.html">MolOps.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1c82d305de578c527eb020669e5ec2ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a>* RDKit::MolOps::addHs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>explicitOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addCoords</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRDKit.html#afd4685678f15f708c0402588adbd5bf7">UINT_VECT</a> *&#160;</td>
          <td class="paramname"><em>onlyOnAtoms</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a copy of a molecule with hydrogens added in as explicit Atoms </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule to add Hs to </td></tr>
    <tr><td class="paramname">explicitOnly</td><td>(optional) if this <code>true</code>, only explicit Hs will be added </td></tr>
    <tr><td class="paramname">addCoords</td><td>(optional) If this is true, estimates for the atomic coordinates of the added Hs will be used. </td></tr>
    <tr><td class="paramname">onlyOnAtoms</td><td>(optional) if provided, this should be a vector of IDs of the atoms that will be considered for H addition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new molecule</dd></dl>
<p><b>Notes:</b></p><ul>
<li>it makes no sense to use the <code>addCoords</code> option if the molecule's heavy atoms don't already have coordinates.</li>
<li>the caller is responsible for <code>delete</code>ing the pointer this returns. </li>
</ul>

</div>
</div>
<a class="anchor" id="a98881884511b4af3bc4958b95530f850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::addHs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>explicitOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addCoords</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRDKit.html#afd4685678f15f708c0402588adbd5bf7">UINT_VECT</a> *&#160;</td>
          <td class="paramname"><em>onlyOnAtoms</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ae2db5d9d43f2a6f90ffbd552b87d4acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::adjustHs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjust the number of implicit and explicit Hs for special cases </p>
<p>Currently this:</p><ul>
<li>modifies aromatic nitrogens so that, when appropriate, they have an explicit H marked (e.g. so that we get things like <code>"c1cc[nH]cc1"</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest</td></tr>
  </table>
  </dd>
</dl>
<p><b>Assumptions</b></p><ul>
<li>this is called after the molecule has been sanitized, aromaticity has been perceived, and the implicit valence of everything has been calculated. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad969f50ae36c9978b0788b0627ac6544"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a>* RDKit::MolOps::adjustQueryProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRDKit_1_1MolOps_1_1AdjustQueryParameters.html">AdjustQueryParameters</a> *&#160;</td>
          <td class="paramname"><em>params</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a copy of a molecule with query properties adjusted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule to adjust </td></tr>
    <tr><td class="paramname">params</td><td>controls the adjustments made</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new molecule </dd></dl>

<p>Referenced by <a class="el" href="MolOps_8h_source.html#l00273">RDKit::MolOps::AdjustQueryParameters::AdjustQueryParameters()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3e97eb4d0e5e2ee77117bd3d554cb84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::adjustQueryProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRDKit_1_1MolOps_1_1AdjustQueryParameters.html">AdjustQueryParameters</a> *&#160;</td>
          <td class="paramname"><em>params</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a582691ed74d9962b18db6bca0b1d6a81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::assignChiralTypesFrom3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>confId</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceExistingTags</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses a conformer to assign ChiralType to a molecule's atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">confId</td><td>the conformer to use </td></tr>
    <tr><td class="paramname">replaceExistingTags</td><td>if this flag is true, any existing atomic chiral tags will be replaced</td></tr>
  </table>
  </dd>
</dl>
<p>If the conformer provided is not a 3D conformer, nothing will be done. </p>

</div>
</div>
<a class="anchor" id="a2862a120b5802558e5b99a9d3e142322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::assignRadicals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by the sanitizer to assign radical counts to atoms. </p>

</div>
</div>
<a class="anchor" id="abae38bdd181c070deee55a4d3ee12885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::assignStereochemistry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanIt</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flagPossibleStereoCenters</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign stereochemistry tags to atoms (i.e. R/S) and bonds (i.e. Z/E) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">cleanIt</td><td>toggles removal of stereo flags from double bonds that can not have stereochemistry </td></tr>
    <tr><td class="paramname">force</td><td>forces the calculation to be repeated even if it has already been done </td></tr>
    <tr><td class="paramname">flagPossibleStereoCenters</td><td>set the _ChiralityPossible property on atoms that are possible stereocenters</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes:M</b></p><ul>
<li>Throughout we assume that we're working with a hydrogen-suppressed graph. </li>
</ul>

</div>
</div>
<a class="anchor" id="af8d126c8da82e0ee29d586e615f26e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::assignStereochemistryFrom3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>confId</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceExistingTags</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses a conformer to assign ChiralTypes to a molecule's atoms and stereo flags to its bonds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">confId</td><td>the conformer to use </td></tr>
    <tr><td class="paramname">replaceExistingTags</td><td>if this flag is true, any existing info about stereochemistry will be replaced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf4728b78ba77bf1662b1c74b1045a7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RDKit::MolOps::atomHasConjugatedBond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1Atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether or not the given <a class="el" href="classRDKit_1_1Atom.html" title="The class for representing atoms. ">Atom</a> is involved in a conjugated bond </p>

</div>
</div>
<a class="anchor" id="ab83e50cc9f72d5a15408cd8818f87c3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::cleanUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Designed to be called by the sanitizer to handle special cases before. </p>
<p>Currently this:</p><ul>
<li>modifies nitro groups, so that the nitrogen does not have an unreasonable valence of 5, as follows:<ul>
<li>the nitrogen gets a positive charge</li>
<li>one of the oxygens gets a negative chage and the double bond to this oxygen is changed to a single bond The net result is that nitro groups can be counted on to be: <code>"[N+](=O)[O-]"</code> </li>
</ul>
</li>
<li>modifies halogen-oxygen containing species as follows: <code></code>[Cl,Br,I](=O)(=O)(=O)O -&gt; [X+3]([O-])([O-])([O-])O <code></code>[Cl,Br,I](=O)(=O)O -&gt; [X+3]([O-])([O-])O <code></code>[Cl,Br,I](=O)O -&gt; [X+]([O-])O</li>
<li>converts the substructure [N,C]=P(=O)-* to [N,C]=[P+](-[O-])-*</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f4af272ca8a5ccb54199ed7584f286a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::cleanupChirality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes bogus chirality markers (those on non-sp3 centers): </p>

</div>
</div>
<a class="anchor" id="afb79c3c6379aac4e7a5d215751b6205e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RDKit::MolOps::computeBalabanJ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBO</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>bondPath</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cacheIt</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates Balaban's J index for the molecule </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">useBO</td><td>toggles inclusion of the bond order in the calculation (when false, we're not really calculating the J value) </td></tr>
    <tr><td class="paramname">force</td><td>forces the calculation (instead of using cached results) </td></tr>
    <tr><td class="paramname">bondPath</td><td>when included, only paths using bonds whose indices occur in this vector will be included in the calculation </td></tr>
    <tr><td class="paramname">cacheIt</td><td>If this is true, the calculated value will be cached as a property on the molecule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the J index </dd></dl>

</div>
</div>
<a class="anchor" id="a974904ad303124381600fb218df3e1b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RDKit::MolOps::computeBalabanJ </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nAts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a66f4444c887732f3d1c9c8acd3b7de12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RDKit::MolOps::countAtomElec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1Atom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the number of electrons available on an atom to donate for </p>
<p>The result is determined using the default valency, number of lone pairs, number of bonds and the formal charge. Note that the atom may not donate all of these electrons to a ring for aromaticity (also used in Conjugation and hybridization code).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">at</td><td>the atom of interest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of electrons </dd></dl>

</div>
</div>
<a class="anchor" id="a992d63a45590b287f310a88228659991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::detectBondStereochemistry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>confId</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses a conformer to assign directionality to the single bonds around double bonds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">confId</td><td>the conformer to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb4723058e660ef77a806981f542003c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::fastFindRings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use a DFS algorithm to identify ring bonds and atoms in a molecule </p>
<p><b>NOTE:</b> though the <a class="el" href="classRDKit_1_1RingInfo.html" title="A class to store information about a molecule&#39;s rings. ">RingInfo</a> structure is populated by this function, the only really reliable calls that can be made are to check if mol.getRingInfo().numAtomRings(idx) or mol.getRingInfo().numBondRings(idx) return values &gt;0 </p>

</div>
</div>
<a class="anchor" id="a11e8a8839c4fb4368631a778e40812ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::findPotentialStereoBonds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanIt</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds bonds that could be cis/trans in a molecule and mark them as <a class="el" href="classRDKit_1_1Bond.html#ae91dd8e72b495a48f46775c874882165ae9c6ddb21e39393f9e57eb5cbdd8b6a1">Bond::STEREOANY</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">cleanIt</td><td>toggles removal of stereo flags from double bonds that can not have stereochemistry</td></tr>
  </table>
  </dd>
</dl>
<p>This function finds any double bonds that can potentially be part of a cis/trans system. No attempt is made here to mark them cis or trans. No attempt is made to detect double bond stereo in ring systems.</p>
<p>This function is useful in the following situations:</p><ul>
<li>when parsing a mol file; for the bonds marked here, coordinate information on the neighbors can be used to indentify cis or trans states</li>
<li>when writing a mol file; bonds that can be cis/trans but not marked as either need to be specially marked in the mol file</li>
<li>finding double bonds with unspecified stereochemistry so they can be enumerated for downstream 3D tools</li>
</ul>
<p>The CIPranks on the neighboring atoms are checked in this function. The _CIPCode property if set to any on the double bond. </p>

</div>
</div>
<a class="anchor" id="ae6e866d1a5ef24aa76a0f5f9ab5217da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RDKit::MolOps::findSSSR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a molecule's Smallest Set of Smallest Rings </p>
<p>Currently this implements a modified form of Figueras algorithm (JCICS - Vol. 36, No. 5, 1996, 986-991)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">res</td><td>used to return the vector of rings. Each entry is a vector with atom indices. This information is also stored in the molecule's <a class="el" href="classRDKit_1_1RingInfo.html" title="A class to store information about a molecule&#39;s rings. ">RingInfo</a> structure, so this argument is optional (see overload)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of smallest rings found</dd></dl>
<p>Base algorithm:</p><ul>
<li>The original algorithm starts by finding representative degree 2 nodes.</li>
<li>Representative because if a series of deg 2 nodes are found only one of them is picked.</li>
<li>The smallest ring around each of them is found.</li>
<li>The bonds that connect to this degree 2 node are them chopped off, yielding new deg two nodes</li>
<li>The process is repeated on the new deg 2 nodes.</li>
<li>If no deg 2 nodes are found, a deg 3 node is picked. The smallest ring with it is found. A bond from this is "carefully" (look in the paper) selected and chopped, yielding deg 2 nodes. The process is same as above once this is done.</li>
</ul>
<p>Our Modifications:</p><ul>
<li>If available, more than one smallest ring around a representative deg 2 node will be computed and stored</li>
<li>Typically 3 rings are found around a degree 3 node (when no deg 2s are available) and all the bond to that node are chopped.</li>
<li>The extra rings that were found in this process are removed after all the nodes have been covered.</li>
</ul>
<p>These changes were motivated by several factors:</p><ul>
<li>We believe the original algorithm fails to find the correct SSSR (finds the correct number of them but the wrong ones) on some sample mols</li>
<li>Since SSSR may not be unique, a post-SSSR step to symmetrize may be done. The extra rings this process adds can be quite useful. </li>
</ul>

<p>Referenced by <a class="el" href="MolDrawing_8h_source.html#l00136">RDKit::Drawing::DrawMol()</a>.</p>

</div>
</div>
<a class="anchor" id="a14ac47e7ee6af9869a0c2fd84b617d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RDKit::MolOps::findSSSR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; *&#160;</td>
          <td class="paramname"><em>res</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a6f2417ccad3a2df24479fbd576ba71e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* RDKit::MolOps::get3DDistanceMat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>confId</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAtomWts</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propNamePrefix</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the molecule's 3D distance matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">confId</td><td>the conformer to use </td></tr>
    <tr><td class="paramname">useAtomWts</td><td>sets the diagonal elements of the result to 6.0/(atomic number) </td></tr>
    <tr><td class="paramname">force</td><td>forces calculation of the matrix, even if already computed </td></tr>
    <tr><td class="paramname">propNamePrefix</td><td>used to set the cached property name (if set to an empty string, the matrix will not be cached)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance matrix.</dd></dl>
<p><b>Notes</b></p><ul>
<li>The result of this is cached in the molecule's local property dictionary, which will handle deallocation. Do the caller should <b>not</b> <code>delete</code> this pointer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a41721af9789cc1c1622c09f7a615c852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* RDKit::MolOps::getAdjacencyMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBO</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>emptyVal</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propNamePrefix</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::dynamic_bitset&lt;&gt; *&#160;</td>
          <td class="paramname"><em>bondsToUse</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a molecule's adjacency matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">useBO</td><td>toggles use of bond orders in the matrix </td></tr>
    <tr><td class="paramname">emptyVal</td><td>sets the empty value (for non-adjacent atoms) </td></tr>
    <tr><td class="paramname">force</td><td>forces calculation of the matrix, even if already computed </td></tr>
    <tr><td class="paramname">propNamePrefix</td><td>used to set the cached property name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adjacency matrix.</dd></dl>
<p><b>Notes</b></p><ul>
<li>The result of this is cached in the molecule's local property dictionary, which will handle deallocation. The caller should <b>not</b> <code>delete</code> this pointer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7077523543dc110f22c90a6cb9790b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* RDKit::MolOps::getDistanceMat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBO</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAtomWts</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propNamePrefix</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the molecule's topological distance matrix. </p>
<p>Uses the Floyd-Warshall all-pairs-shortest-paths algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">useBO</td><td>toggles use of bond orders in the matrix </td></tr>
    <tr><td class="paramname">useAtomWts</td><td>sets the diagonal elements of the result to 6.0/(atomic number) so that the matrix can be used to calculate Balaban J values. This does not affect the bond weights. </td></tr>
    <tr><td class="paramname">force</td><td>forces calculation of the matrix, even if already computed </td></tr>
    <tr><td class="paramname">propNamePrefix</td><td>used to set the cached property name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance matrix.</dd></dl>
<p><b>Notes</b></p><ul>
<li>The result of this is cached in the molecule's local property dictionary, which will handle deallocation. The caller should <b>not</b> <code>delete</code> this pointer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a02f6a3c606682fe0393b9b859cced79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* RDKit::MolOps::getDistanceMat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>activeAtoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classRDKit_1_1Bond.html">Bond</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bonds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBO</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAtomWts</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the molecule's topological distance matrix. </p>
<p>Uses the Floyd-Warshall all-pairs-shortest-paths algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">activeAtoms</td><td>only elements corresponding to these atom indices will be included in the calculation </td></tr>
    <tr><td class="paramname">bonds</td><td>only bonds found in this list will be included in the calculation </td></tr>
    <tr><td class="paramname">useBO</td><td>toggles use of bond orders in the matrix </td></tr>
    <tr><td class="paramname">useAtomWts</td><td>sets the diagonal elements of the result to 6.0/(atomic number) so that the matrix can be used to calculate Balaban J values. This does not affect the bond weights.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance matrix.</dd></dl>
<p><b>Notes</b></p><ul>
<li>The results of this call are not cached, the caller <b>should</b> <code>delete</code> this pointer. </li>
</ul>

</div>
</div>
<a class="anchor" id="a383f0b5365adccf4810682f44f1e519c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RDKit::MolOps::getFormalCharge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sums up all atomic formal charges and returns the result </p>

</div>
</div>
<a class="anchor" id="ad8100d785d32fb3c173b83949766b87b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RDKit::MolOps::getMolFrags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find fragments (disconnected components of the molecular graph) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">mapping</td><td>used to return the mapping of Atoms-&gt;fragments. On return <code>mapping</code> will be <code>mol-&gt;getNumAtoms()</code> long and will contain the fragment assignment for each <a class="el" href="classRDKit_1_1Atom.html" title="The class for representing atoms. ">Atom</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fragments found. </dd></dl>

</div>
</div>
<a class="anchor" id="a2812dd5ae2d896a76f7c3e53df00e655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RDKit::MolOps::getMolFrags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>frags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find fragments (disconnected components of the molecular graph) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">frags</td><td>used to return the Atoms in each fragment On return <code>mapping</code> will be <code>numFrags</code> long, and each entry will contain the indices of the Atoms in that fragment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fragments found. </dd></dl>

</div>
</div>
<a class="anchor" id="a961d74791d3a7670fa336a0e8a5b821e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::shared_ptr&lt;<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a>&gt; &gt; RDKit::MolOps::getMolFrags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sanitizeFrags</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>frags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; *&#160;</td>
          <td class="paramname"><em>fragsMolAtomMapping</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyConformers</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>splits a molecule into its component fragments </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">sanitizeFrags</td><td>toggles sanitization of the fragments after they are built </td></tr>
    <tr><td class="paramname">frags</td><td>used to return the mapping of Atoms-&gt;fragments. if provided, <code>frags</code> will be <code>mol-&gt;getNumAtoms()</code> long on return and will contain the fragment assignment for each <a class="el" href="classRDKit_1_1Atom.html" title="The class for representing atoms. ">Atom</a> </td></tr>
    <tr><td class="paramname">fragsMolAtomMapping</td><td>used to return the Atoms in each fragment On return <code>mapping</code> will be <code>numFrags</code> long, and each entry will contain the indices of the Atoms in that fragment. </td></tr>
    <tr><td class="paramname">copyConformers</td><td>toggles copying conformers of the fragments after they are built </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the fragments as smart pointers to ROMols </dd></dl>

</div>
</div>
<a class="anchor" id="aa1fd7c52b582bfcc1e0578c4190c9154"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;T, boost::shared_ptr&lt;<a class="el" href="classRDKit_1_1ROMol.html">ROMol</a>&gt; &gt; RDKit::MolOps::getMolFragsWithQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(*)(const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;, const <a class="el" href="classRDKit_1_1Atom.html">Atom</a> *)&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sanitizeFrags</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>whiteList</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>negateList</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>splits a molecule into pieces based on labels assigned using a query </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">query</td><td>the query used to "label" the molecule for fragmentation </td></tr>
    <tr><td class="paramname">sanitizeFrags</td><td>toggles sanitization of the fragments after they are built </td></tr>
    <tr><td class="paramname">whiteList</td><td>if provided, only labels in the list will be kept </td></tr>
    <tr><td class="paramname">negateList</td><td>if true, the white list logic will be inverted: only labels not in the list will be kept</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map of the fragments and their labels </dd></dl>

</div>
</div>
<a class="anchor" id="a72217aa97105f29efcb1d710380a761c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned RDKit::MolOps::getNumAtomsWithDistinctProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of atoms which have a particular property set </p>

</div>
</div>
<a class="anchor" id="a00c563124730b9be240998dfc49e7509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;int&gt; RDKit::MolOps::getShortestPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aid2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the shortest path between two atoms. </p>
<p>Uses the Bellman-Ford algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>molecule of interest </td></tr>
    <tr><td class="paramname">aid1</td><td>index of the first atom </td></tr>
    <tr><td class="paramname">aid2</td><td>index of the second atom</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an std::list with the indices of the atoms along the shortest path</dd></dl>
<p><b>Notes:</b></p><ul>
<li>the starting and end atoms are included in the path</li>
<li>if no path is found, an empty path is returned </li>
</ul>

</div>
</div>
<a class="anchor" id="a97703326c0e03b5ce2571db51a4f2d37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::Kekulize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>markAtomsBonds</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxBackTracks</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kekulizes the molecule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
    <tr><td class="paramname">markAtomsBonds</td><td>if this is set to true, <code>isAromatic</code> boolean settings on both the Bonds and Atoms are turned to false following the Kekulization, otherwise they are left alone in their original state. </td></tr>
    <tr><td class="paramname">maxBackTracks</td><td>the maximum number of attempts at back-tracking. The algorithm uses a back-tracking procedure to revist a previous setting of double bond if we hit a wall in the kekulization process</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes:</b></p><ul>
<li>even if <code>markAtomsBonds</code> is <code>false</code> the <code>BondType</code> for all aromatic bonds will be changed from <code><a class="el" href="classRDKit_1_1Bond.html#a2c93af0aeb3297ee77b6afdc27b68d6fa5d2471c2ac8376c305370e7f78eba288">RDKit::Bond::AROMATIC</a></code> to <code><a class="el" href="classRDKit_1_1Bond.html#a2c93af0aeb3297ee77b6afdc27b68d6fad881ede45d3a0957f2fd0613f889c3aa">RDKit::Bond::SINGLE</a></code> or <a class="el" href="classRDKit_1_1Bond.html#a2c93af0aeb3297ee77b6afdc27b68d6fa8af85de15e5828979dd3d53bab8bf866">RDKit::Bond::DOUBLE</a> during Kekulization. </li>
</ul>

<p>Referenced by <a class="el" href="MolDrawing_8h_source.html#l00399">RDKit::Drawing::MolToDrawing()</a>.</p>

</div>
</div>
<a class="anchor" id="a94eb4f320aefffa2f90ad625465588eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a>* RDKit::MolOps::mergeQueryHs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mergeUnmappedOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns a copy of a molecule with hydrogens removed and added as queries to the heavy atoms to which they are bound.</p>
<p>This is really intended to be used with molecules that contain QueryAtoms</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule to remove Hs from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new molecule</dd></dl>
<p><b>Notes:</b></p><ul>
<li>Atoms that do not already have hydrogen count queries will have one added, other H-related queries will not be touched. Examples:<ul>
<li>C[H] -&gt; [C;!H0]</li>
<li>[C;H1][H] -&gt; [C;H1]</li>
<li>[C;H2][H] -&gt; [C;H2]</li>
</ul>
</li>
<li>Hydrogens which aren't connected to a heavy atom will not be removed. This prevents molecules like <code>"[H][H]"</code> from having all atoms removed.</li>
<li>the caller is responsible for <code>delete</code>ing the pointer this returns.</li>
<li>By default all hydrogens are removed, however if mergeUnmappedOnly is true, any hydrogen participating in an atom map will be retained </li>
</ul>

</div>
</div>
<a class="anchor" id="a7b3b2fd7381895536a4199e411238d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::mergeQueryHs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mergeUnmappedOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af107496a733ec110568d56b46e6a85fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a>* RDKit::MolOps::removeHs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicitOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateExplicitCount</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sanitize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a copy of a molecule with hydrogens removed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule to remove Hs from </td></tr>
    <tr><td class="paramname">implicitOnly</td><td>(optional) if this <code>true</code>, only implicit Hs will be removed </td></tr>
    <tr><td class="paramname">updateExplicitCount</td><td>(optional) If this is <code>true</code>, when explicit Hs are removed from the graph, the heavy atom to which they are bound will have its counter of explicit Hs increased. </td></tr>
    <tr><td class="paramname">sanitize</td><td>(optional) If this is <code>true</code>, the final molecule will be sanitized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new molecule</dd></dl>
<p><b>Notes:</b></p><ul>
<li>Hydrogens which aren't connected to a heavy atom will not be removed. This prevents molecules like <code>"[H][H]"</code> from having all atoms removed.</li>
<li>Labelled hydrogen (e.g. atoms with atomic number=1, but mass &gt; 1), will not be removed.</li>
<li>two coordinate Hs, like the central H in C[H-]C, will not be removed</li>
<li>Hs connected to dummy atoms will not be removed</li>
<li>the caller is responsible for <code>delete</code>ing the pointer this returns. </li>
</ul>

<p>Referenced by <a class="el" href="MolSupplier_8h_source.html#l00078">RDKit::ForwardSDMolSupplier::ForwardSDMolSupplier()</a>, <a class="el" href="MolSupplier_8h_source.html#l00122">RDKit::SDMolSupplier::SDMolSupplier()</a>, and <a class="el" href="MolSupplier_8h_source.html#l00140">RDKit::SDMolSupplier::~SDMolSupplier()</a>.</p>

</div>
</div>
<a class="anchor" id="a6910ee11522058972aaf5d882f0c965a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::removeHs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicitOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateExplicitCount</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sanitize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aaaea0d3a71758b1598a1be8df2171edf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::removeStereochemistry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all stereochemistry information from atoms (i.e. R/S) and bonds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96649cb8953d6b3ab6dfd43f639cafd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a>* RDKit::MolOps::renumberAtoms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>newOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a copy of a molecule with the atoms renumbered </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the molecule to work with </td></tr>
    <tr><td class="paramname">newOrder</td><td>the new ordering of the atoms (should be numAtoms long) for example: if newOrder is [3,2,0,1], then atom 3 in the original molecule will be atom 0 in the new one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new molecule</dd></dl>
<p><b>Notes:</b></p><ul>
<li>the caller is responsible for <code>delete</code>ing the pointer this returns. </li>
</ul>

<p>Referenced by <a class="el" href="MolOps_8h_source.html#l00273">RDKit::MolOps::AdjustQueryParameters::AdjustQueryParameters()</a>.</p>

</div>
</div>
<a class="anchor" id="afeb89201d884ccf4ed79328f9b4ebce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::sanitizeMol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>operationThatFailed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sanitizeOps</em> = <code><a class="el" href="namespaceRDKit_1_1MolOps.html#a84fb27eb77609bdfe7e1c00a41f3494fa0250c83e840bd3708e4e0a9516667538">SANITIZE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>carries out a collection of tasks for cleaning up a molecule and </p>
<p>that it makes "chemical sense"</p>
<p>This functions calls the following in sequence</p><ol type="1">
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#ab83e50cc9f72d5a15408cd8818f87c3d" title="Designed to be called by the sanitizer to handle special cases before. ">MolOps::cleanUp()</a></li>
<li>mol.updatePropertyCache()</li>
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#a032bdc967b1d512bfbf1c36c0f0d6a31" title="symmetrize the molecule&#39;s Smallest Set of Smallest Rings ">MolOps::symmetrizeSSSR()</a></li>
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#a97703326c0e03b5ce2571db51a4f2d37" title="Kekulizes the molecule. ">MolOps::Kekulize()</a></li>
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#a2862a120b5802558e5b99a9d3e142322" title="Called by the sanitizer to assign radical counts to atoms. ">MolOps::assignRadicals()</a></li>
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#acb1e9490835888ac4afb636354906e1d" title="Sets up the aromaticity for a molecule. ">MolOps::setAromaticity()</a></li>
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#a6958f372a9637b1331dcde8bb38b99ea" title="flags the molecule&#39;s conjugated bonds ">MolOps::setConjugation()</a></li>
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#a33b9724fc353ae2b5f3af2f0664ebf87" title="calculates and sets the hybridization of all a molecule&#39;s Stoms ">MolOps::setHybridization()</a></li>
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#a4f4af272ca8a5ccb54199ed7584f286a" title="removes bogus chirality markers (those on non-sp3 centers): ">MolOps::cleanupChirality()</a></li>
<li><a class="el" href="namespaceRDKit_1_1MolOps.html#ae2db5d9d43f2a6f90ffbd552b87d4acf" title="adjust the number of implicit and explicit Hs for special cases ">MolOps::adjustHs()</a></li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>: the <a class="el" href="classRDKit_1_1RWMol.html" title="RWMol is a molecule class that is intended to be edited. ">RWMol</a> to be cleaned</td></tr>
    <tr><td class="paramname">operationThatFailed</td><td>: the first (if any) sanitization operation that fails is set here. The values are taken from the <code>SanitizeFlags</code> enum. On success, the value is <code>SanitizeFlags::SANITIZE_NONE</code> </td></tr>
    <tr><td class="paramname">sanitizeOps</td><td>: the bits here are used to set which sanitization operations are carried out. The elements of the <code>SanitizeFlags</code> enum define the operations.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes:</b></p><ul>
<li>If there is a failure in the sanitization, a <code>SanitException</code> will be thrown.</li>
<li>in general the user of this function should cast the molecule following this function to a <a class="el" href="classRDKit_1_1ROMol.html" title="ROMol is a molecule class that is intended to have a fixed topology. ">ROMol</a>, so that new atoms and bonds cannot be added to the molecule and screw up the sanitizing that has been done here </li>
</ul>

</div>
</div>
<a class="anchor" id="aa62db8a3732ccd00ef4b7f52517f2c5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::sanitizeMol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="acb1e9490835888ac4afb636354906e1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RDKit::MolOps::setAromaticity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ec">AromaticityModel</a>&#160;</td>
          <td class="paramname"><em>model</em> = <code><a class="el" href="namespaceRDKit_1_1MolOps.html#a3dcbb725ec35a926b18aa7938fcea3ecac7d815cbfd690b24d6888a655456c939">AROMATICITY_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(<a class="el" href="classRDKit_1_1RWMol.html">RWMol</a> &amp;)&#160;</td>
          <td class="paramname"><em>func</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the aromaticity for a molecule. </p>
<p>This is what happens here:</p><ol type="1">
<li>find all the simple rings by calling the findSSSR function</li>
<li>loop over all the Atoms in each ring and mark them if they are candidates for aromaticity. A ring atom is a candidate if it can spare electrons to the ring and if it's from the first two rows of the periodic table.</li>
<li>based on the candidate atoms, mark the rings to be either candidates or non-candidates. A ring is a candidate only if all its atoms are candidates</li>
<li>apply Hueckel rule to each of the candidate rings to check if the ring can be aromatic</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>the <a class="el" href="classRDKit_1_1RWMol.html" title="RWMol is a molecule class that is intended to be edited. ">RWMol</a> of interest </td></tr>
    <tr><td class="paramname">model</td><td>the aromaticity model to use </td></tr>
    <tr><td class="paramname">func</td><td>a custom function for assigning aromaticity (only used when model=<code>AROMATICITY_CUSTOM</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 on success, &lt;= 0 otherwise</dd></dl>
<p><b>Assumptions:</b></p><ul>
<li>Kekulization has been done (i.e. <code><a class="el" href="namespaceRDKit_1_1MolOps.html#a97703326c0e03b5ce2571db51a4f2d37" title="Kekulizes the molecule. ">MolOps::Kekulize()</a></code> has already been called) </li>
</ul>

</div>
</div>
<a class="anchor" id="a6958f372a9637b1331dcde8bb38b99ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::setConjugation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flags the molecule's conjugated bonds </p>

</div>
</div>
<a class="anchor" id="a33b9724fc353ae2b5f3af2f0664ebf87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RDKit::MolOps::setHybridization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates and sets the hybridization of all a molecule's Stoms </p>

</div>
</div>
<a class="anchor" id="a032bdc967b1d512bfbf1c36c0f0d6a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RDKit::MolOps::symmetrizeSSSR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>symmetrize the molecule's Smallest Set of Smallest Rings </p>
<p>SSSR rings obatined from "findSSSR" can be non-unique in some case. For example, cubane has five SSSR rings, not six as one would hope.</p>
<p>This function adds additional rings to the SSSR list if necessary to make the list symmetric, e.g. all atoms in cubane will be part of the same number of SSSRs. This function choses these extra rings from the extra rings computed and discarded during findSSSR. The new ring are chosen such that:</p><ul>
<li>replacing a same sized ring in the SSSR list with an extra ring yields the same union of bond IDs as the orignal SSSR list</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>- the molecule of interest </td></tr>
    <tr><td class="paramname">res</td><td>used to return the vector of rings. Each entry is a vector with atom indices. This information is also stored in the molecule's <a class="el" href="classRDKit_1_1RingInfo.html" title="A class to store information about a molecule&#39;s rings. ">RingInfo</a> structure, so this argument is optional (see overload)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of rings = (new rings + old SSSRs)</dd></dl>
<p><b>Notes:</b></p><ul>
<li>if no SSSR rings are found on the molecule - <a class="el" href="namespaceRDKit_1_1MolOps.html#ae6e866d1a5ef24aa76a0f5f9ab5217da" title="finds a molecule&#39;s Smallest Set of Smallest Rings ">MolOps::findSSSR()</a> is called first </li>
</ul>

</div>
</div>
<a class="anchor" id="a3c5e8e6d6dae2c1c6ad93ee3a00c2911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RDKit::MolOps::symmetrizeSSSR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRDKit_1_1ROMol.html">ROMol</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceRDKit.html">RDKit</a></li><li class="navelem"><a class="el" href="namespaceRDKit_1_1MolOps.html">MolOps</a></li>
    <li class="footer">Generated on Tue Jan 23 2018 11:03:08 for RDKit by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
